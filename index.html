<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Battle City Style - Enhanced Version</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #2a2a2a;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        /* STARTUP MENU STYLES */
        #startupMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #1a1a1a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s ease-out;
        }

        #startupMenu.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .menu-title {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 3px 3px 8px rgba(255, 0, 0, 0.8);
            margin-bottom: 20px;
            text-align: center;
            animation: titlePulse 2s infinite alternate;
        }

        @keyframes titlePulse {
            0% { text-shadow: 3px 3px 8px rgba(255, 0, 0, 0.8); }
            100% { text-shadow: 3px 3px 15px rgba(255, 0, 0, 1), 0 0 25px rgba(255, 0, 0, 0.5); }
        }

        .menu-subtitle {
            font-size: 18px;
            color: #ccc;
            margin-bottom: 40px;
            text-align: center;
        }

        .menu-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }

        .menu-button {
            width: 300px;
            height: 60px;
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.2) 0%, rgba(255, 100, 0, 0.2) 100%);
            border: 3px solid #ff4400;
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            user-select: none;
        }

        .menu-button:hover {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.4) 0%, rgba(255, 100, 0, 0.4) 100%);
            border-color: #ff6600;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 68, 0, 0.6);
        }

        .menu-button:active {
            transform: scale(0.95);
            box-shadow: 0 0 10px rgba(255, 68, 0, 0.8);
        }

        .menu-button.disabled {
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(150, 150, 150, 0.2) 100%);
            border-color: #666;
            color: #999;
            cursor: not-allowed;
        }

        .menu-button.disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .menu-version {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #666;
            font-size: 12px;
        }

        .menu-controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #999;
            font-size: 14px;
            text-align: left;
        }

        /* GAME CONTAINER - HIDDEN BY DEFAULT */
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 80vh; /* Increased from 60vh to 80vh */
            background: #1a1a1a;
            border: 2px solid #444;
            overflow: hidden;
            display: none; /* Hidden until game starts */
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .tank {
            position: absolute;
            width: 50px;
            height: 50px;
            transition: transform 0.1s ease-out;
            z-index: 10;
            transform-origin: center center;
        }

        .tank img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            filter: drop-shadow(2px 2px 4px rgba(255,0,0,0.8));
            transform: scale(1.2);
            /* Fix alignment by ensuring proper centering */
            display: block;
            margin: auto;
        }

        .enemy-tank {
            position: absolute;
            width: 50px;
            height: 50px;
            transition: transform 0.1s ease-out;
            z-index: 9;
            transform-origin: center center;
        }

        .enemy-tank img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.8));
            transform: scale(1.2);
            /* Fix enemy tank alignment */
            display: block;
            margin: auto;
        }

        .enemy-tank.frozen {
            filter: drop-shadow(2px 2px 4px rgba(0,255,255,0.8)) hue-rotate(180deg) brightness(0.8);
        }

        .enemy-tank.hit {
            filter: drop-shadow(0 0 10px rgba(255,255,255,1)) brightness(1.5);
            animation: hitFlash 0.3s ease-out;
        }

        @keyframes hitFlash {
            0% { transform: scale(1.2); }
            50% { transform: scale(1.4); }
            100% { transform: scale(1.2); }
        }

        .boss {
            position: absolute;
            width: 200px;  /* Much bigger - giant size */
            height: 200px;
            z-index: 12;
            transform-origin: center center;
            filter: drop-shadow(0 0 20px rgba(128, 0, 255, 0.5));
        }

        .boss img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            filter: drop-shadow(4px 4px 8px rgba(255,0,255,0.8));
        }

        .boss.hit {
            filter: drop-shadow(0 0 15px rgba(255,255,255,1)) brightness(1.8);
            animation: bossHitFlash 0.5s ease-out;
        }

        @keyframes bossHitFlash {
            0% { transform: scale(1); }
            25% { transform: scale(1.1); }
            50% { transform: scale(1.2); }
            75% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .bullet {
            position: absolute;
            width: 8px;   /* Smaller, more precise bullet */
            height: 8px;
            z-index: 5;
            transform-origin: center center;
            border-radius: 50%; /* Make it perfectly round */
            background: #ffff00; /* Yellow background for fallback */
        }

        .bullet img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            filter: drop-shadow(0 0 4px #ffff00);
            /* Fix bullet alignment */
            display: block;
            margin: auto;
            transform: none; /* Remove any unwanted transforms */
            border-radius: 50%; /* Ensure bullet image is round */
        }

        .enemy-bullet {
            position: absolute;
            width: 12px;
            height: 12px;
            z-index: 5;
            transform-origin: center center;
        }

        .enemy-bullet img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            filter: drop-shadow(0 0 4px #ff4444);
        }

        .rocket {
            position: absolute;
            width: 16px;
            height: 16px;
            z-index: 6;
            transform-origin: center center;
        }

        .rocket::before {
            content: '🚀';
            font-size: 16px;
            position: absolute;
            top: -2px;
            left: -2px;
            filter: drop-shadow(0 0 6px #ff6600);
        }

        .missile {
            position: absolute;
            width: 35px;
            height: 35px;
            z-index: 7;
            transform-origin: center center;
        }

        .missile img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            filter: drop-shadow(0 0 12px #ff4400);
        }

        .flame {
            position: absolute;
            width: 30px;
            height: 30px;
            z-index: 6;
            transform-origin: center center;
        }

        .flame img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            filter: drop-shadow(0 0 10px #ff6600);
        }

        .freeze-blast {
            position: absolute;
            width: 35px;
            height: 35px;
            z-index: 6;
            transform-origin: center center;
        }

        .freeze-blast img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            filter: drop-shadow(0 0 12px #00ffff);
        }

        .obstacle {
            position: absolute;
            width: 40px;
            height: 40px;
            z-index: 3;
        }

        .obstacle img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .powerup {
            position: absolute;
            width: 30px;
            height: 30px;
            z-index: 4;
            animation: powerupPulse 1s infinite alternate;
        }

        .powerup img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        @keyframes powerupPulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.2); }
        }

        .powerup.disappearing {
            animation: powerupDisappear 1s ease-out forwards;
        }

        @keyframes powerupDisappear {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.5); }
        }

        #controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20vh; /* Reduced from 40vh to 20vh */
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            transition: transform 0.3s ease;
            display: none; /* Hidden until game starts */
        }

        #controls.hidden {
            transform: translateY(100%);
        }

        .controls-toggle {
            position: fixed;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid #fff;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 1000;
            font-size: 14px;
            display: none; /* Hidden until game starts */
        }

        .dpad {
            position: relative;
            width: 120px;
            height: 120px;
        }

        .dpad-button {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #fff;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
        }

        .dpad-up {
            top: 0;
            left: 40px;
            width: 40px;
            height: 40px;
        }

        .dpad-down {
            bottom: 0;
            left: 40px;
            width: 40px;
            height: 40px;
        }

        .dpad-left {
            left: 0;
            top: 40px;
            width: 40px;
            height: 40px;
        }

        .dpad-right {
            right: 0;
            top: 40px;
            width: 40px;
            height: 40px;
        }

        .action-buttons {
            display: flex;
            flex-direction: row; /* Changed from column to row */
            flex-wrap: wrap; /* Allow wrapping to multiple rows */
            gap: 12px; /* Increased gap for better spacing */
            align-items: center;
            justify-content: center;
            max-width: 400px; /* Limit width for better layout */
        }

        .shoot-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 0, 0, 0.3);
            border: 3px solid #ff0000;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
        }

        .stage-button, .test-button {
            width: 65px;  /* Optimized for horizontal layout */
            height: 30px; /* Better height for visibility */
            border-radius: 8px;
            border: 2px solid;
            color: #fff;
            font-size: 8px; /* Compact font size */
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            margin: 2px; /* Small margin for spacing */
            line-height: 1.1; /* Better line spacing for multi-line text */
        }

        .stage-button {
            background: rgba(0, 255, 0, 0.3);
            border-color: #00ff00;
        }

        .powerup-button {
            background: rgba(255, 255, 0, 0.3);
            border-color: #ffff00;
        }

        .boss-button {
            background: rgba(255, 0, 255, 0.3);
            border-color: #ff00ff;
        }

        .enemy-button {
            background: rgba(255, 100, 0, 0.3);
            border-color: #ff6400;
        }

        .bigtank-button {
            background: rgba(139, 69, 19, 0.4);
            border-color: #8b4513;
        }

        .two-player-button {
            background: rgba(0, 150, 255, 0.3);
            border-color: #0096ff;
        }

        .two-player-button.active {
            background: rgba(0, 150, 255, 0.7);
            border-color: #0096ff;
        }

        .button-pressed {
            background: rgba(255, 255, 255, 0.5) !important;
            transform: scale(0.95);
        }

        .shoot-pressed {
            background: rgba(255, 0, 0, 0.7) !important;
            transform: scale(0.95);
        }

        .test-pressed {
            background: rgba(255, 255, 255, 0.7) !important;
            transform: scale(0.95);
        }

        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #stageInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #audioControls {
            position: absolute;
            top: 40px;
            left: 10px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        #powerupStatus {
            position: absolute;
            top: 60px;
            left: 10px;
            color: #00ff00;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #weaponStatus {
            position: absolute;
            top: 80px;
            left: 10px;
            color: #ffff00;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #powerupStatus2 {
            position: absolute;
            top: 100px;
            left: 10px;
            color: #00ff00;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #weaponStatus2 {
            position: absolute;
            top: 120px;
            left: 10px;
            color: #ffff00;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #bossHealth {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff00ff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            display: none;
        }

        .health-bar {
            width: 200px;
            height: 10px;
            background: rgba(255,0,0,0.3);
            border: 1px solid #fff;
            margin-top: 5px;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Background Music -->
    <audio id="backgroundMusic" loop autoplay>
        <source src="assists/sfx/music1.mp3" type="audio/mpeg">
        <source src="assists/sfx/music2.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <!-- Sound Effects -->
    <audio id="cannonSound" preload="auto">
        <source src="assists/sfx/canon.mp3" type="audio/mpeg">
    </audio>

    <audio id="explodeSound" preload="auto">
        <source src="assists/sfx/explode.mp3" type="audio/mpeg">
    </audio>

    <audio id="flamethrowerSound" preload="auto">
        <source src="assists/sfx/flamethrower.mp3" type="audio/mpeg">
    </audio>

    <audio id="freezethrowerSound" preload="auto">
        <source src="assists/sfx/freezethrower.mp3" type="audio/mpeg">
    </audio>

    <!-- Visual Effect Sounds - Using existing sounds -->
    <audio id="burningSound1" preload="auto">
        <source src="assists/sfx/flamethrower.mp3" type="audio/mpeg">
    </audio>
    <audio id="burningSound2" preload="auto">
        <source src="assists/sfx/flamethrower.mp3" type="audio/mpeg">
    </audio>
    <audio id="burningSound3" preload="auto">
        <source src="assists/sfx/flamethrower.mp3" type="audio/mpeg">
    </audio>
    <audio id="burningSound4" preload="auto">
        <source src="assists/sfx/flamethrower.mp3" type="audio/mpeg">
    </audio>

    <audio id="destroySound1" preload="auto">
        <source src="assists/sfx/explode.mp3" type="audio/mpeg">
    </audio>
    <audio id="destroySound2" preload="auto">
        <source src="assists/sfx/explode.mp3" type="audio/mpeg">
    </audio>
    <audio id="destroySound3" preload="auto">
        <source src="assists/sfx/explode.mp3" type="audio/mpeg">
    </audio>
    <audio id="destroySound4" preload="auto">
        <source src="assists/sfx/explode.mp3" type="audio/mpeg">
    </audio>
    <audio id="destroySound5" preload="auto">
        <source src="assists/sfx/explode.mp3" type="audio/mpeg">
    </audio>

    <audio id="getFreezeSound1" preload="auto">
        <source src="assists/sfx/freezethrower.mp3" type="audio/mpeg">
    </audio>
    <audio id="getFreezeSound2" preload="auto">
        <source src="assists/sfx/freezethrower.mp3" type="audio/mpeg">
    </audio>
    <audio id="getFreezeSound3" preload="auto">
        <source src="assists/sfx/freezethrower.mp3" type="audio/mpeg">
    </audio>

    <!-- STARTUP MENU -->
    <div id="startupMenu">
        <div class="menu-title">TANK BATTLE CITY</div>
        <div class="menu-subtitle">Enhanced Edition</div>
        
        <div class="menu-options">
            <div class="menu-button" id="onePlayerButton">
                1 PLAYER MODE
            </div>
            <div class="menu-button" id="twoPlayerButton">
                2 PLAYER MODE
            </div>
            <div class="menu-button disabled" id="optionsButton">
                OPTIONS
            </div>
            <div class="menu-button" id="debugButton" style="display: none;">
                DEBUG MODE
            </div>
        </div>

        <div class="menu-version">v2.0 Enhanced</div>
        <div class="menu-controls-hint">
            Controls:<br>
            Player 1: Arrow Keys/WASD + Spacebar<br>
            Player 2: IJKL + Right Shift
        </div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="tank" class="tank">
            <img id="tankBody" src="assists/sprits/tankp1.png" alt="Player 1 Tank">
        </div>
        <div id="tank2" class="tank" style="display: none;">
            <img id="tank2Body" src="assists/sprits/tankp2.png" alt="Player 2 Tank">
        </div>
        <div id="score">Score: 0</div>
        <div id="score2" style="display: none;">Player 2 Score: 0</div>
        <div id="lives" style="position: absolute; top: 140px; left: 10px; color: #fff; font-size: 12px; font-weight: bold;">P1 Lives: 4</div>
        <div id="lives2" style="position: absolute; top: 160px; left: 10px; color: #fff; font-size: 12px; font-weight: bold; display: none;">P2 Lives: 4</div>
        <div id="enemyCounter" style="position: absolute; top: 40px; right: 10px; color: #fff; font-size: 12px; font-weight: bold;">Enemies: 0/19</div>
        <div id="stageInfo">Stage: 1</div>
        <div id="audioControls">🔊 Music: ON</div>
        <div id="powerupStatus">P1 Power: None</div>
        <div id="powerupStatus2" style="display: none;">P2 Power: None</div>
        <div id="weaponStatus">P1 Weapon: Single Shot</div>
        <div id="weaponStatus2" style="display: none;">P2 Weapon: Single Shot</div>
        <div id="bossHealth">
            Boss Health
            <div class="health-bar">
                <div class="health-fill" style="width: 100%"></div>
            </div>
        </div>
    </div>

    <button class="controls-toggle" id="controlsToggle">Hide Controls</button>

    <div id="controls">
        <div class="dpad">
            <div class="dpad-button dpad-up" data-direction="up">↑</div>
            <div class="dpad-button dpad-down" data-direction="down">↓</div>
            <div class="dpad-button dpad-left" data-direction="left">←</div>
            <div class="dpad-button dpad-right" data-direction="right">→</div>
        </div>
        <div class="action-buttons">
            <div class="shoot-button" id="shootButton">FIRE</div>
            <div class="two-player-button test-button" id="twoPlayerButton">2 PLAYERS<br>OFF</div>
            <div class="stage-button test-button" id="stageButton">NEXT<br>STAGE</div>
            <div class="powerup-button test-button" id="powerupButton">SPAWN<br>POWERUP</div>
            <div class="boss-button test-button" id="bossButton">SPAWN<br>BOSS</div>
            <!-- Enemy Spawn Buttons -->
            <div class="enemy-button test-button" id="enemyButton">SPAWN<br>ENEMY</div>
            <div class="bigtank-button test-button" id="bigTankButton">SPAWN<br>BIG TANK</div>
        </div>
    </div>

    <script>
        class TankGame {
            constructor() {
                console.log('Initializing Tank Game...');
                
                // Initialize startup menu first
                this.gameStarted = false;
                this.setupStartupMenu();
                
                this.tank = document.getElementById('tank');
                this.gameContainer = document.getElementById('gameContainer');
                this.gameCanvas = document.getElementById('gameCanvas');
                this.scoreElement = document.getElementById('score');
                this.stageInfoElement = document.getElementById('stageInfo');
                this.backgroundMusic = document.getElementById('backgroundMusic');
                this.audioControls = document.getElementById('audioControls');
                this.cannonSound = document.getElementById('cannonSound');
                this.explodeSound = document.getElementById('explodeSound');
                this.flamethrowerSound = document.getElementById('flamethrowerSound');
                this.freezethrowerSound = document.getElementById('freezethrowerSound');
                
                // Visual effect sounds
                this.burningSounds = [
                    document.getElementById('burningSound1'),
                    document.getElementById('burningSound2'),
                    document.getElementById('burningSound3'),
                    document.getElementById('burningSound4')
                ];
                this.destroySounds = [
                    document.getElementById('destroySound1'),
                    document.getElementById('destroySound2'),
                    document.getElementById('destroySound3'),
                    document.getElementById('destroySound4'),
                    document.getElementById('destroySound5')
                ];
                this.getFreezeSounds = [
                    document.getElementById('getFreezeSound1'),
                    document.getElementById('getFreezeSound2'),
                    document.getElementById('getFreezeSound3')
                ];
                this.powerupStatus = document.getElementById('powerupStatus');
                this.weaponStatus = document.getElementById('weaponStatus');
                this.bossHealth = document.getElementById('bossHealth');
                this.controlsToggle = document.getElementById('controlsToggle');
                this.controls = document.getElementById('controls');
                this.livesElement = document.getElementById('lives');
                this.lives2Element = document.getElementById('lives2');
                this.enemyCounterElement = document.getElementById('enemyCounter');
                
                // Check if all elements were found
                if (!this.tank || !this.gameContainer || !this.gameCanvas) {
                    console.error('Failed to find required game elements!');
                    return;
                }
                
                console.log('All game elements found successfully.');
                
                // Initialize game but don't start yet
                this.initializeGameData();
                
                // Start the game loop (it will wait for gameStarted to be true)
                this.gameLoop();
                
                console.log('Enhanced Tank Battle City Game initialized successfully!');
                console.log('Waiting for player to select game mode from startup menu...');
            }

            setupStartupMenu() {
                const onePlayerButton = document.getElementById('onePlayerButton');
                const twoPlayerButton = document.getElementById('twoPlayerButton');
                const optionsButton = document.getElementById('optionsButton');
                const debugButton = document.getElementById('debugButton');
                
                // Cheat code detection
                this.cheatSequence = '';
                this.debugMode = false;
                this.infiniteHealth = false;
                
                onePlayerButton.addEventListener('click', () => {
                    this.startGame(false); // Single player mode
                });
                
                twoPlayerButton.addEventListener('click', () => {
                    this.startGame(true); // Two player mode
                });
                
                optionsButton.addEventListener('click', () => {
                    // Placeholder for options menu
                    alert('Options menu coming soon!');
                });
                
                debugButton.addEventListener('click', () => {
                    this.startGame(false, true); // Debug mode
                });
                
                // Cheat code listener
                document.addEventListener('keydown', (e) => {
                    if (!this.gameStarted) {
                        // Only listen for cheat codes on title screen or during game
                        this.cheatSequence += e.key.toLowerCase();
                        
                        // Keep only last 10 characters to prevent memory buildup
                        if (this.cheatSequence.length > 10) {
                            this.cheatSequence = this.cheatSequence.slice(-10);
                        }
                        
                        // Check for "milo" sequence
                        if (this.cheatSequence.includes('milo')) {
                            if (!this.debugMode) {
                                this.enableDebugMode();
                            }
                            this.cheatSequence = ''; // Reset after activation
                        }
                    } else if (this.gameStarted) {
                        // During game, check for infinite health cheat
                        this.cheatSequence += e.key.toLowerCase();
                        
                        if (this.cheatSequence.length > 10) {
                            this.cheatSequence = this.cheatSequence.slice(-10);
                        }
                        
                        if (this.cheatSequence.includes('milo')) {
                            this.toggleInfiniteHealth();
                            this.cheatSequence = '';
                        }
                    }
                });
                
                console.log('Startup menu initialized');
            }

            enableDebugMode() {
                this.debugMode = true;
                const debugButton = document.getElementById('debugButton');
                debugButton.style.display = 'block';
                console.log('Debug mode enabled! Debug button is now visible.');
                
                // Visual feedback
                debugButton.style.animation = 'titlePulse 0.5s ease-in-out 3';
            }

            toggleInfiniteHealth() {
                this.infiniteHealth = !this.infiniteHealth;
                console.log(`Infinite health: ${this.infiniteHealth ? 'ON' : 'OFF'}`);
                
                // Visual feedback in game
                if (this.infiniteHealth) {
                    this.gameContainer.style.border = '4px solid #00ff00';
                    this.scoreElement.textContent += ' [INF HEALTH]';
                } else {
                    this.gameContainer.style.border = '2px solid #444';
                    this.scoreElement.textContent = this.scoreElement.textContent.replace(' [INF HEALTH]', '');
                }
            }

            startGame(twoPlayerMode = false, debugMode = false) {
                console.log(`Starting game in ${twoPlayerMode ? '2-Player' : '1-Player'} mode${debugMode ? ' (DEBUG)' : ''}...`);
                
                this.twoPlayerMode = twoPlayerMode;
                this.gameStarted = true;
                this.isDebugMode = debugMode;
                
                // Hide startup menu
                const startupMenu = document.getElementById('startupMenu');
                startupMenu.classList.add('hidden');
                
                // Remove startup menu after transition
                setTimeout(() => {
                    startupMenu.style.display = 'none';
                }, 500);
                
                // Show game elements
                this.gameContainer.style.display = 'block';
                this.controls.style.display = 'flex';
                this.controlsToggle.style.display = 'block';
                
                // Hide/Show debug buttons based on mode
                const debugButtons = document.querySelectorAll('.test-button');
                debugButtons.forEach(button => {
                    if (debugMode) {
                        button.style.display = 'flex';
                    } else {
                        button.style.display = 'none';
                    }
                });
                
                // Enable two-player elements if needed
                if (this.twoPlayerMode) {
                    this.tank2.style.display = 'block';
                    this.score2Element.style.display = 'block';
                    this.powerupStatus2.style.display = 'block';
                    this.weaponStatus2.style.display = 'block';
                    
                    // Update two-player button in controls to show it's active
                    const twoPlayerControlButton = document.getElementById('twoPlayerButton');
                    if (twoPlayerControlButton) {
                        twoPlayerControlButton.textContent = '2 PLAYERS\nON';
                        twoPlayerControlButton.classList.add('active');
                    }
                }
                
                // Start the actual game
                this.preloadAssets();
                this.setupAudio();
                this.setupControls();
                this.updateTankPosition();
                this.updateTankRotation();
                this.loadStage();
                this.initializeGameplay();
                this.updateWeaponStatus();
                
                // Initialize powerup auto-spawning timer
                this.powerupSpawnTimer = Date.now();
                
                if (this.twoPlayerMode) {
                    this.updateWeaponStatus2();
                    this.updatePowerupStatus2();
                }
                
                // Start the game loop
                console.log('Starting game loop...');
                this.gameLoop();
                
                // Spawn initial enemy group for normal gameplay (after everything is set up)
                if (!debugMode && this.enemiesKilled < this.maxEnemiesBeforeBoss && !this.bossSpawned) {
                    console.log('Normal mode: spawning initial enemies...');
                    setTimeout(() => {
                        this.spawnEnemyGroup();
                    }, 1000);
                } else if (!debugMode) {
                    console.log('Not spawning initial enemies - kill limit reached or boss spawned');
                }
                
                console.log(`Game started in ${twoPlayerMode ? '2-Player' : '1-Player'} mode!`);
                console.log('Controls: Arrow keys/WASD to move, Spacebar/Enter to shoot');
                console.log('Features: 4 power-ups, boss fights, weapon upgrades, hit feedback');
            }

            initializeGameData() {
                // Player 1 Tank state - RED TANK (player), no sliding movement
                this.tankPosition = { x: 100, y: 200 };
                this.tankDirection = 'up';
                this.tankSpeed = 2.0; // Increased for snappy movement
                this.isMoving = false;
                
                // Two-Player System
                this.twoPlayerMode = false;
                this.tank2 = document.getElementById('tank2');
                this.tank2Body = document.getElementById('tank2Body');
                this.score2Element = document.getElementById('score2');
                this.powerupStatus2 = document.getElementById('powerupStatus2');
                this.weaponStatus2 = document.getElementById('weaponStatus2');
                
                // Player 2 Tank state - BLUE TANK (player 2)
                this.tank2Position = { x: 200, y: 400 };
                this.tank2Direction = 'up';
                this.tank2Speed = 2.0;
                this.tank2IsMoving = false;
                this.tank2WeaponLevel = 1;
                this.tank2CurrentPowerup = null;
                this.tank2LastShotTime = 0;
                this.tank2HasActiveShot = false;
                this.tank2LastFlamethrowerSound = 0;
                this.tank2LastFreezethrowerSound = 0;
                
                // Player 2 Movement
                this.tank2CurrentDirection = null;
                this.tank2PressedKeys = new Set();
                
                // Player 2 Score (Player 1 score initialized later)
                this.score2 = 0;
                
                // Xbox Controller Support (Multiple Controllers)
                this.gamepads = {
                    player1: { connected: false, index: -1 },
                    player2: { connected: false, index: -1 }
                };
                this.gamepadConnected = false; // Legacy support
                this.gamepadIndex = -1; // Legacy support
                
                // Enemy state - BLACK TANK (3 hits to destroy)
                this.enemies = [];
                this.maxEnemies = 1;
                this.enemySpeed = 1.0;
                this.enemyLastShot = 0;
                this.enemyShootInterval = 3000;
                this.enemyTypes = [
                    'assists/sprits/car1.png',
                    'assists/sprits/tank-blue.png'
                ]; // Multiple enemy types (removed ai-black.png - doesn't exist)
                this.frozenEnemies = new Set();
                this.enemyHitPoints = new Map(); // Track enemy hit points
                
                // Boss state
                this.boss = null;
                this.bossMaxHealth = 12; // Increased from 6 to 12
                this.bossCurrentHealth = 12;
                this.bossLastAttack = 0;
                this.bossAttackInterval = 2000;
                
                // Projectile state
                this.bullets = [];
                this.enemyBullets = [];
                this.rockets = [];
                this.missiles = [];
                this.flames = [];
                this.freezeBlasts = [];
                this.bulletSpeed = 3.0;
                this.enemyBulletSpeed = 2.0;
                this.rocketSpeed = 4.0;
                this.missileSpeed = 5.5; // Faster missile speed
                this.flameSpeed = 2.5;
                this.freezeSpeed = 2.8;
                this.lastShotTime = 0;
                this.shotCooldown = 200; // Faster shooting
                this.hasActiveShot = false;
                
                // Sound cooldowns for special weapons (1 second)
                this.lastFlamethrowerSound = 0;
                this.lastFreezethrowerSound = 0;
                this.specialWeaponSoundCooldown = 1000; // 1 second
                
                // Visual Effects Tracking
                this.burningTanks = new Map(); // tankId -> {startTime, damageTimer, effectElement}
                this.frozenEffects = new Map(); // tankId -> {effectElement, soundPlayed}
                this.burningDuration = 2000; // 2 seconds
                this.burningDamageInterval = 500; // Damage every 500ms while burning
                
                // Weapon upgrade system
                this.weaponLevel = 1; // 1 = single, 2 = double, 3 = triple
                this.maxWeaponLevel = 3;
                
                // Power-up state - only one active at a time
                this.currentPowerup = null;
                this.powerupDuration = 30000; // 30 seconds before disappearing
                
                // Obstacles (collisions commented out as requested)
                this.obstacles = [];
                this.obstacleTypes = [
                    'assists/collisions/box.png',
                    'assists/collisions/barrel.png',
                    'assists/collisions/lamp.png',
                    'assists/collisions/water.png',
                    'assists/collisions/base.png',
                    'assists/collisions/base-x.png'
                ];
                
                // Power-ups - new transparent PNGs as requested
                this.powerups = [];
                this.powerupTypes = [
                    'assists/powers/freeze.png',    // Freeze thrower with icy blast
                    'assists/powers/flame.png',     // Flamethrower with realistic fire
                    'assists/powers/missile.png',   // Homing missile with red tip
                    'assists/powers/star.png'       // Bullet upgrade (2 then 3 shots)
                ];
                
                // Game state
                this.score = 0;
                this.currentStage = 1;
                this.maxStages = 5;
                
                // Lives system
                this.player1Lives = 5;
                this.player2Lives = 5;
                this.gameOver = false;
                this.victorySong = false;
                
                // Initialize lives display
                this.updateLivesDisplay();
                
                // Gameplay timers
                this.powerupSpawnTimer = 0;
                this.powerupSpawnInterval = 25000; // 25 seconds
                this.enemiesKilled = 0;
                this.maxEnemiesBeforeBoss = 19;
                this.currentEnemyCount = 0;
                this.maxEnemies = 3; // Maximum 3 enemies on screen at once
                this.enemiesPerSpawn = 3; // 3 enemies per group
                this.bossSpawned = false;
                this.bossDefeated = false;
                
                // Stage backgrounds
                this.stageBackgrounds = [
                    'assists/stages/stage1.png',
                    'assists/stages/stage2.png', 
                    'assists/stages/stage3.png',
                    'assists/stages/stage4.png',
                    'assists/stages/stage1.png'  // Fallback to stage1 for stage 5
                ];
                
                // Container dimensions - adjust for larger screen
                this.containerWidth = window.innerWidth;
                this.containerHeight = window.innerHeight * 0.8; // Increased for bigger screen
                this.tankSize = 50;
                this.obstacleSize = 40;
                this.powerupSize = 30;
                this.bossSize = 200;  /* Updated to match giant boss size */
                
                // Input state
                this.pressedKeys = new Set();
                this.currentDirection = null;
                
                console.log('Game data initialized');
            }

            preloadAssets() {
                console.log('Preloading game assets...');
                
                // Create placeholder power-up images (you'll replace these with actual transparent PNGs)
                this.createPlaceholderPowerups();
                
                const imagesToPreload = [
                    ...this.stageBackgrounds,
                    ...this.obstacleTypes,
                    ...this.powerupTypes,
                    ...this.enemyTypes,
                    'assists/sprits/tankp1.png',
                    'assists/sprits/bullet.png'
                ];

                let loadedCount = 0;
                let totalImages = imagesToPreload.length;

                imagesToPreload.forEach(src => {
                    const img = new Image();
                    img.onload = () => {
                        loadedCount++;
                        console.log(`Loaded: ${src} (${loadedCount}/${totalImages})`);
                        if (loadedCount === totalImages) {
                            console.log('All assets preloaded successfully!');
                        }
                    };
                    img.onerror = () => {
                        console.warn(`Failed to load: ${src}`);
                        loadedCount++;
                    };
                    img.src = src;
                });

                console.log(`Started preloading ${totalImages} assets...`);
            }

            createPlaceholderPowerups() {
                console.log('Placeholder power-ups created (replace with actual transparent PNGs)');
            }

            setupAudio() {
                const musicTracks = ['assists/sfx/music1.mp3', 'assists/sfx/music2.mp3'];
                const randomTrack = musicTracks[Math.floor(Math.random() * musicTracks.length)];
                
                this.backgroundMusic.innerHTML = `<source src="${randomTrack}" type="audio/mpeg">`;
                this.backgroundMusic.load();
                
                this.backgroundMusic.volume = 1.0;  // Maximum volume for music
                this.cannonSound.volume = 0.15;     // Reduced cannon sound
                this.explodeSound.volume = 0.2;     // Reduced explosion sound
                this.flamethrowerSound.volume = 0.3; // Flamethrower sound
                this.freezethrowerSound.volume = 0.3; // Freezethrower sound
                
                const playMusic = () => {
                    this.backgroundMusic.play().catch(e => {
                        console.log('Autoplay prevented, waiting for user interaction');
                    });
                };
                
                playMusic();
                document.addEventListener('click', playMusic, { once: true });
                document.addEventListener('touchstart', playMusic, { once: true });
                
                this.audioControls.addEventListener('click', () => {
                    if (this.backgroundMusic.paused) {
                        this.backgroundMusic.play();
                        this.audioControls.textContent = '🔊 Music: ON';
                    } else {
                        this.backgroundMusic.pause();
                        this.audioControls.textContent = '🔇 Music: OFF';
                    }
                });
            }

            playBossMusic() {
                console.log('Switching to boss music...');
                try {
                    // Stop current music
                    if (this.backgroundMusic) {
                        this.backgroundMusic.pause();
                        this.backgroundMusic.currentTime = 0;
                    }
                    
                    // Switch to boss music
                    this.backgroundMusic.innerHTML = '<source src="assists/sfx/bossfight1.mp3" type="audio/mpeg">';
                    this.backgroundMusic.load();
                    this.backgroundMusic.volume = 1.0;
                    this.backgroundMusic.loop = true; // Loop boss music
                    
                    // Play boss music with delay to ensure loading
                    setTimeout(() => {
                        this.backgroundMusic.play().then(() => {
                            console.log('Boss music started successfully');
                        }).catch(e => {
                            console.log('Boss music failed to play:', e);
                        });
                    }, 200);
                } catch(e) {
                    console.log('Boss music error:', e);
                }
            }

            playCannonSound() {
                try {
                    this.cannonSound.currentTime = 0;
                    this.cannonSound.play().catch(e => console.log('Cannon sound failed:', e));
                } catch(e) {
                    console.log('Cannon sound error:', e);
                }
            }

            playExplodeSound() {
                try {
                    this.explodeSound.currentTime = 0;
                    this.explodeSound.play().catch(e => console.log('Explode sound failed:', e));
                } catch(e) {
                    console.log('Explode sound error:', e);
                }
            }

            playFlamethrowerSound() {
                const currentTime = Date.now();
                if (currentTime - this.lastFlamethrowerSound < this.specialWeaponSoundCooldown) {
                    return; // Skip playing sound if still in cooldown
                }
                
                try {
                    this.flamethrowerSound.currentTime = 0;
                    this.flamethrowerSound.play().catch(e => console.log('Flamethrower sound failed:', e));
                    this.lastFlamethrowerSound = currentTime; // Update last played time
                } catch(e) {
                    console.log('Flamethrower sound error:', e);
                }
            }

            playFreezeThrowerSound() {
                const currentTime = Date.now();
                if (currentTime - this.lastFreezethrowerSound < this.specialWeaponSoundCooldown) {
                    return; // Skip playing sound if still in cooldown
                }
                
                try {
                    this.freezethrowerSound.currentTime = 0;
                    this.freezethrowerSound.play().catch(e => console.log('Freezethrower sound failed:', e));
                    this.lastFreezethrowerSound = currentTime; // Update last played time
                } catch(e) {
                    console.log('Freezethrower sound error:', e);
                }
            }

            playBurningSound() {
                try {
                    const randomSound = this.burningSounds[Math.floor(Math.random() * this.burningSounds.length)];
                    randomSound.currentTime = 0;
                    // Vary volume for burning effects
                    randomSound.volume = 0.15 + Math.random() * 0.1; // 0.15 to 0.25
                    randomSound.playbackRate = 0.8 + Math.random() * 0.4; // 0.8 to 1.2x speed
                    randomSound.play().catch(e => console.log('Burning sound failed:', e));
                } catch(e) {
                    console.log('Burning sound error:', e);
                }
            }

            playDestroySound() {
                try {
                    const randomSound = this.destroySounds[Math.floor(Math.random() * this.destroySounds.length)];
                    randomSound.currentTime = 0;
                    // Vary volume for explosion effects
                    randomSound.volume = 0.25 + Math.random() * 0.15; // 0.25 to 0.4
                    randomSound.playbackRate = 0.9 + Math.random() * 0.2; // 0.9 to 1.1x speed
                    randomSound.play().catch(e => console.log('Destroy sound failed:', e));
                } catch(e) {
                    console.log('Destroy sound error:', e);
                }
            }

            playGetFreezeSound() {
                try {
                    const randomSound = this.getFreezeSounds[Math.floor(Math.random() * this.getFreezeSounds.length)];
                    randomSound.currentTime = 0;
                    // Vary volume for freeze effects
                    randomSound.volume = 0.2 + Math.random() * 0.1; // 0.2 to 0.3
                    randomSound.playbackRate = 0.7 + Math.random() * 0.6; // 0.7 to 1.3x speed
                    randomSound.play().catch(e => console.log('Get freeze sound failed:', e));
                } catch(e) {
                    console.log('Get freeze sound error:', e);
                }
            }

            // VISUAL EFFECTS SYSTEM
            createBurningEffect(tank, tankId) {
                // Play burning sound
                this.playBurningSound();
                
                // Create burning visual effect
                const burningEffect = document.createElement('div');
                burningEffect.className = 'burning-effect';
                burningEffect.style.position = 'absolute';
                burningEffect.style.width = '60px';
                burningEffect.style.height = '60px';
                burningEffect.style.left = (tank.x - 5) + 'px';
                burningEffect.style.top = (tank.y - 5) + 'px';
                burningEffect.style.zIndex = '15';
                burningEffect.style.pointerEvents = 'none';
                
                // Create burning animation frames
                const burningImg = document.createElement('img');
                burningImg.src = 'assists/sfx/burning1.png';
                burningImg.style.width = '100%';
                burningImg.style.height = '100%';
                burningImg.style.objectFit = 'contain';
                burningImg.style.imageRendering = 'pixelated';
                burningImg.alt = 'Burning Effect';
                
                burningEffect.appendChild(burningImg);
                this.gameContainer.appendChild(burningEffect);
                
                // Track burning effect
                const currentTime = Date.now();
                this.burningTanks.set(tankId, {
                    startTime: currentTime,
                    damageTimer: currentTime,
                    lastFrameTime: currentTime,
                    effectElement: burningEffect,
                    burningImg: burningImg,
                    currentFrame: 1,
                    tank: tank
                });
                
                console.log(`Tank ${tankId} is now burning!`);
            }

            createFreezeEffect(tank, tankId) {
                // Play get freeze sound
                this.playGetFreezeSound();
                
                // Create freeze visual effect
                const freezeEffect = document.createElement('div');
                freezeEffect.className = 'freeze-effect';
                freezeEffect.style.position = 'absolute';
                freezeEffect.style.width = '60px';
                freezeEffect.style.height = '60px';
                freezeEffect.style.left = (tank.x - 5) + 'px';
                freezeEffect.style.top = (tank.y - 5) + 'px';
                freezeEffect.style.zIndex = '15';
                freezeEffect.style.pointerEvents = 'none';
                
                // Create freeze animation frames
                const freezeImg = document.createElement('img');
                freezeImg.src = 'assists/sfx/getfreeze1.png';
                freezeImg.style.width = '100%';
                freezeImg.style.height = '100%';
                freezeImg.style.objectFit = 'contain';
                freezeImg.style.imageRendering = 'pixelated';
                freezeImg.alt = 'Freeze Effect';
                
                freezeEffect.appendChild(freezeImg);
                this.gameContainer.appendChild(freezeEffect);
                
                // Track freeze effect
                this.frozenEffects.set(tankId, {
                    effectElement: freezeEffect,
                    freezeImg: freezeImg,
                    currentFrame: 1,
                    lastFrameTime: Date.now(),
                    tank: tank
                });
                
                console.log(`Tank ${tankId} freeze effect created!`);
            }

            createDestroyEffect(x, y) {
                // Play destroy sound
                this.playDestroySound();
                
                // Create destroy visual effect
                const destroyEffect = document.createElement('div');
                destroyEffect.className = 'destroy-effect';
                destroyEffect.style.position = 'absolute';
                destroyEffect.style.width = '80px';
                destroyEffect.style.height = '80px';
                destroyEffect.style.left = (x - 15) + 'px';
                destroyEffect.style.top = (y - 15) + 'px';
                destroyEffect.style.zIndex = '16';
                destroyEffect.style.pointerEvents = 'none';
                
                // Create destroy animation frames
                const destroyImg = document.createElement('img');
                destroyImg.src = 'assists/sfx/destroy1.png';
                destroyImg.style.width = '100%';
                destroyImg.style.height = '100%';
                destroyImg.style.objectFit = 'contain';
                destroyImg.style.imageRendering = 'pixelated';
                destroyImg.alt = 'Destroy Effect';
                
                destroyEffect.appendChild(destroyImg);
                this.gameContainer.appendChild(destroyEffect);
                
                // Animate destroy effect (destroy1.png to destroy5.png)
                let currentFrame = 1;
                const animateDestroy = () => {
                    currentFrame++;
                    if (currentFrame <= 5) {
                        destroyImg.src = `assists/sfx/destroy${currentFrame}.png`;
                        setTimeout(animateDestroy, 100); // Change frame every 100ms
                    } else {
                        // Remove effect after animation
                        destroyEffect.remove();
                    }
                };
                
                setTimeout(animateDestroy, 100);
                console.log('Destroy effect created!');
            }

            updateWeaponStatus() {
                let weaponText = '';
                switch(this.weaponLevel) {
                    case 1:
                        weaponText = 'P1 Weapon: Single Shot';
                        break;
                    case 2:
                        weaponText = 'P1 Weapon: Double Shot';
                        break;
                    case 3:
                        weaponText = 'P1 Weapon: Triple Shot';
                        break;
                }
                this.weaponStatus.textContent = weaponText;
            }

            updatePowerupStatus() {
                if (this.currentPowerup) {
                    const powerupName = this.currentPowerup.type.split('/').pop().split('.')[0];
                    this.powerupStatus.textContent = `P1 Power: ${powerupName.toUpperCase()}`;
                } else {
                    this.powerupStatus.textContent = 'P1 Power: None';
                }
            }

            updateLivesDisplay() {
                if (this.livesElement) {
                    this.livesElement.textContent = `P1 Lives: ${this.player1Lives}`;
                }
                if (this.lives2Element) {
                    this.lives2Element.textContent = `P2 Lives: ${this.player2Lives}`;
                }
                if (this.enemyCounterElement) {
                    this.enemyCounterElement.textContent = `Enemies: ${this.enemiesKilled}/${this.maxEnemiesBeforeBoss}`;
                }
            }

            // BOSS SYSTEM - 3D Robot Boss
            spawnBoss() {
                if (this.boss) {
                    console.log('Boss already exists');
                    return;
                }

                // Create container for 3D boss
                const bossContainer = document.createElement('div');
                bossContainer.className = 'boss';
                bossContainer.style.width = '200px';
                bossContainer.style.height = '200px';
                bossContainer.style.position = 'absolute';
                bossContainer.style.zIndex = '12';

                // Create 2D robot boss using your PNG file
                const robotImg = document.createElement('img');
                robotImg.src = 'assists/sprits/boss1.png';
                robotImg.style.width = '100%';
                robotImg.style.height = '100%';
                robotImg.style.objectFit = 'contain';
                robotImg.style.imageRendering = 'pixelated';
                
                bossContainer.appendChild(robotImg);

                // Position boss on map randomly
                let x, y;
                const edge = Math.floor(Math.random() * 4);
                switch(edge) {
                    case 0: // top
                        x = Math.random() * (this.containerWidth - 200);
                        y = 0;
                        break;
                    case 1: // right
                        x = this.containerWidth - 200;
                        y = Math.random() * (this.containerHeight - 200);
                        break;
                    case 2: // bottom
                        x = Math.random() * (this.containerWidth - 200);
                        y = this.containerHeight - 200;
                        break;
                    case 3: // left
                        x = 0;
                        y = Math.random() * (this.containerHeight - 200);
                        break;
                }
                
                bossContainer.style.left = x + 'px';
                bossContainer.style.top = y + 'px';
                
                this.gameContainer.appendChild(bossContainer);
                
                this.boss = {
                    element: bossContainer,
                    x: x,
                    y: y,
                    health: this.bossMaxHealth,
                    lastAttack: 0,
                    moveDirection: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
                    lastDirectionChange: Date.now()
                };
                
                this.bossCurrentHealth = this.bossMaxHealth;
                this.updateBossHealthBar();
                this.bossHealth.style.display = 'block';
                
                console.log('2D Robot boss spawned at:', { x, y });
            }

            updateBossHealthBar() {
                const healthPercent = (this.bossCurrentHealth / this.bossMaxHealth) * 100;
                const healthFill = this.bossHealth.querySelector('.health-fill');
                if (healthFill) {
                    healthFill.style.width = healthPercent + '%';
                }
            }

            updateBoss() {
                if (!this.boss) return;

                const currentTime = Date.now();
                const playerDistance = Math.sqrt(
                    Math.pow(this.boss.x - this.tankPosition.x, 2) + 
                    Math.pow(this.boss.y - this.tankPosition.y, 2)
                );

                /* SMART BOSS MOVEMENT - Walking animation and intelligent pathfinding */
                if (currentTime - this.boss.lastDirectionChange > 1500) {
                    // Smart boss AI - move toward player but not too predictably
                    const dx = this.tankPosition.x - this.boss.x;
                    const dy = this.tankPosition.y - this.boss.y;
                    
                    let newDirection;
                    if (playerDistance > 250) {
                        // Far from player - move toward player
                        if (Math.abs(dx) > Math.abs(dy)) {
                            newDirection = dx > 0 ? 'right' : 'left';
                        } else {
                            newDirection = dy > 0 ? 'down' : 'up';
                        }
                    } else if (playerDistance < 100) {
                        // Too close - move away occasionally (25% chance) or circle around
                        if (Math.random() < 0.25) {
                            // Move away
                            if (Math.abs(dx) > Math.abs(dy)) {
                                newDirection = dx > 0 ? 'left' : 'right';
                            } else {
                                newDirection = dy > 0 ? 'up' : 'down';
                            }
                        } else {
                            // Circle around player
                            const directions = ['up', 'down', 'left', 'right'];
                            newDirection = directions[Math.floor(Math.random() * directions.length)];
                        }
                    } else {
                        // Good distance - strategic movement
                        const directions = ['up', 'down', 'left', 'right'];
                        const playerDirection = Math.abs(dx) > Math.abs(dy) 
                            ? (dx > 0 ? 'right' : 'left')
                            : (dy > 0 ? 'down' : 'up');
                        
                        // 60% toward player, 40% random/tactical
                        newDirection = Math.random() < 0.6 ? playerDirection : directions[Math.floor(Math.random() * directions.length)];
                    }
                    
                    this.boss.moveDirection = newDirection;
                    this.boss.lastDirectionChange = currentTime;
                }

                let newX = this.boss.x;
                let newY = this.boss.y;
                const bossSpeed = 1.2; // Normal walking speed

                switch(this.boss.moveDirection) {
                    case 'up':
                        newY -= bossSpeed;
                        break;
                    case 'down':
                        newY += bossSpeed;
                        break;
                    case 'left':
                        newX -= bossSpeed;
                        break;
                    case 'right':
                        newX += bossSpeed;
                        break;
                }

                // Keep boss in bounds
                if (newX >= 0 && newX <= this.containerWidth - this.bossSize &&
                    newY >= 0 && newY <= this.containerHeight - this.bossSize) {
                    this.boss.x = newX;
                    this.boss.y = newY;
                    this.boss.element.style.left = this.boss.x + 'px';
                    this.boss.element.style.top = this.boss.y + 'px';
                    
                    // Walking animation effect with proper directional rotation
                    const walkCycle = Math.floor(currentTime / 200) % 2; // Change every 200ms
                    let bossRotation = 0;
                    
                    // Set proper rotation based on movement direction
                    switch(this.boss.moveDirection) {
                        case 'up':
                            bossRotation = 180;    // Match player tank rotation
                            break;
                        case 'down':
                            bossRotation = 0;      // Match player tank rotation
                            break;
                        case 'left':
                            bossRotation = 90;     // Match player tank rotation
                            break;
                        case 'right':
                            bossRotation = 270;    // Match player tank rotation
                            break;
                    }
                    
                    // Combine directional rotation with walking animation
                    const walkingOffset = walkCycle === 0 ? 1 : -1;
                    const scale = walkCycle === 0 ? 1 : 1.02;
                    this.boss.element.style.transform = `scale(${scale}) rotate(${bossRotation + walkingOffset}deg)`;
                }

                /* SMART WEAPON SELECTION based on distance */
                if (currentTime - this.boss.lastAttack > this.bossAttackInterval) {
                    if (playerDistance > 300) {
                        // Far away - use rockets (homing missiles)
                        this.bossAttackMissile();
                        console.log('Boss uses ROCKETS - Player is far away');
                    } else if (playerDistance > 120) {
                        // Medium distance - use machine gun
                        this.bossAttackMachineGun();
                        console.log('Boss uses MACHINE GUN - Player at medium range');
                    } else {
                        // Close range - use kick attack
                        this.bossAttackKick();
                        console.log('Boss uses KICK - Player is close');
                    }
                    this.boss.lastAttack = currentTime;
                }
            }

            bossAttackMissile() {
                console.log('Boss fires missile!');
                this.playCannonSound();
                
                // Create homing missile targeting player
                const missile = document.createElement('div');
                missile.className = 'missile';
                missile.innerHTML = '<img src="assists/sfx/missile.png" alt="Boss Missile">';
                
                const startX = this.boss.x + this.bossSize / 2;
                const startY = this.boss.y + this.bossSize / 2;
                
                missile.style.left = startX + 'px';
                missile.style.top = startY + 'px';
                
                this.gameContainer.appendChild(missile);
                
                this.missiles.push({
                    element: missile,
                    x: startX,
                    y: startY,
                    isEnemyMissile: true,
                    target: { x: this.tankPosition.x, y: this.tankPosition.y }
                });
            }

            bossAttackMachineGun() {
                console.log('Boss fires machine gun!');
                this.playCannonSound();
                
                // Fire 3 bullets in spread pattern
                for (let i = 0; i < 3; i++) {
                    const bullet = document.createElement('div');
                    bullet.className = 'enemy-bullet';
                    bullet.innerHTML = '<img src="assists/sprits/bullet.png" alt="Boss Bullet">';
                    
                    const startX = this.boss.x + this.bossSize / 2;
                    const startY = this.boss.y + this.bossSize / 2;
                    
                    bullet.style.left = startX + 'px';
                    bullet.style.top = startY + 'px';
                    
                    this.gameContainer.appendChild(bullet);
                    
                    // Calculate direction towards player with spread
                    const dx = this.tankPosition.x - startX;
                    const dy = this.tankPosition.y - startY;
                    const angle = Math.atan2(dy, dx) + (i - 1) * 0.3; // Spread bullets
                    
                    this.enemyBullets.push({
                        element: bullet,
                        x: startX,
                        y: startY,
                        dx: Math.cos(angle) * this.enemyBulletSpeed,
                        dy: Math.sin(angle) * this.enemyBulletSpeed,
                        isBossBullet: true
                    });
                }
            }

            bossAttackKick() {
                console.log('Boss kicks! (Close combat)');
                
                // Enhanced visual kick effect
                this.boss.element.style.transform = 'scale(1.2) rotate(5deg)';
                this.boss.element.style.filter = 'brightness(1.5) drop-shadow(0 0 20px #ff0000)';
                
                setTimeout(() => {
                    if (this.boss) {
                        this.boss.element.style.transform = 'scale(1)';
                        this.boss.element.style.filter = 'none';
                    }
                }, 400);
                
                // Check if player is close enough to be hit
                const distance = Math.sqrt(
                    Math.pow(this.boss.x - this.tankPosition.x, 2) + 
                    Math.pow(this.boss.y - this.tankPosition.y, 2)
                );
                
                if (distance < 120) { // Increased range for giant boss
                    this.handlePlayerHit();
                }
            }

            handleBossHit() {
                if (!this.boss) return;

                this.bossCurrentHealth--;
                this.updateBossHealthBar();
                
                // Visual feedback
                this.boss.element.classList.add('hit');
                setTimeout(() => {
                    if (this.boss) {
                        this.boss.element.classList.remove('hit');
                    }
                }, 500);

                console.log(`Boss hit! Health: ${this.bossCurrentHealth}/${this.bossMaxHealth}`);

                if (this.bossCurrentHealth <= 0) {
                    this.destroyBoss();
                }
            }

            destroyBoss() {
                if (!this.boss) return;

                console.log('Boss destroyed!');
                this.playExplodeSound();
                
                this.score += 1000;
                this.scoreElement.textContent = `Score: ${this.score}`;
                
                // Visual explosion effect
                this.gameContainer.style.background = '#ffff00';
                setTimeout(() => {
                    this.gameContainer.style.background = '#1a1a1a';
                }, 500);

                this.boss.element.remove();
                this.boss = null;
                this.bossHealth.style.display = 'none';
                this.bossDefeated = true;
                
                // Victory! Return to title screen after celebration
                console.log('VICTORY! Boss defeated!');
                setTimeout(() => {
                    this.showVictoryScreen();
                }, 2000);
            }
            
            showVictoryScreen() {
                // Stop all music
                this.backgroundMusic.pause();
                
                // Show victory message
                alert(`🎉 VICTORY! 🎉\n\nBoss Defeated!\nFinal Score: ${this.score}\n\nReturning to title screen...`);
                
                // Reset game and return to title
                this.resetGame();
                this.returnToTitle();
            }
            
            resetGame() {
                // Reset all game state
                this.gameStarted = false;
                this.bossSpawned = false;
                this.bossDefeated = false;
                this.enemiesKilled = 0;
                this.currentEnemyCount = 0;
                this.score = 0;
                this.score2 = 0;
                this.player1Lives = 5; // Reset to 5 lives
                this.player2Lives = 5;
                
                // Clear all entities
                this.enemies.forEach(enemy => enemy.element.remove());
                this.enemies = [];
                this.bullets.forEach(bullet => bullet.element.remove());
                this.bullets = [];
                this.enemyBullets.forEach(bullet => bullet.element.remove());
                this.enemyBullets = [];
                this.missiles.forEach(missile => missile.element.remove());
                this.missiles = [];
                this.powerups.forEach(powerup => powerup.element.remove());
                this.powerups = [];
                
                // Reset tank positions
                this.tankPosition = { x: 100, y: 200 };
                this.tank2Position = { x: 200, y: 400 };
                
                console.log('Game reset complete');
            }
            
            returnToTitle() {
                // Hide game elements
                this.gameContainer.style.display = 'none';
                this.controls.style.display = 'none';
                this.controlsToggle.style.display = 'none';
                
                // Show startup menu
                const startupMenu = document.getElementById('startupMenu');
                startupMenu.style.display = 'flex';
                startupMenu.classList.remove('hidden');
                
                // Restart background music with random track
                this.setupAudio();
                
                console.log('Returned to title screen');
            }
            
            showGameOverScreen(player) {
                // Stop all music
                this.backgroundMusic.pause();
                
                // Show game over message
                alert(`💀 GAME OVER 💀\n\n${player} ran out of lives!\nFinal Score: ${this.score}\n\nReturning to title screen...`);
                
                // Reset game and return to title
                this.resetGame();
                this.returnToTitle();
            }

            // POWER-UP SYSTEM (Enhanced)
            spawnRandomPowerup() {
                // Remove existing power-up if any
                if (this.powerups.length > 0) {
                    this.powerups.forEach(powerup => powerup.element.remove());
                    this.powerups = [];
                }

                const powerupType = this.powerupTypes[Math.floor(Math.random() * this.powerupTypes.length)];
                const x = Math.random() * (this.containerWidth - this.powerupSize);
                const y = Math.random() * (this.containerHeight - this.powerupSize);
                
                this.createPowerup(x, y, powerupType);
                
                // Play power-up spawn sound
                this.playCannonSound(); // Use existing sound or add dedicated power-up sound
                
                // Auto-disappear after duration
                setTimeout(() => {
                    if (this.powerups.length > 0) {
                        const powerup = this.powerups[0];
                        powerup.element.classList.add('disappearing');
                        setTimeout(() => {
                            if (powerup.element && powerup.element.parentNode) {
                                powerup.element.remove();
                                this.powerups = [];
                            }
                        }, 1000);
                    }
                }, this.powerupDuration);
                
                console.log('Random power-up spawned:', powerupType);
            }

            createPowerup(x, y, type) {
                const powerup = document.createElement('div');
                powerup.className = 'powerup';
                powerup.innerHTML = `<img src="${type}" alt="Power-up">`;
                powerup.style.left = x + 'px';
                powerup.style.top = y + 'px';
                
                this.gameContainer.appendChild(powerup);
                
                this.powerups.push({
                    element: powerup,
                    x: x,
                    y: y,
                    width: this.powerupSize,
                    height: this.powerupSize,
                    type: type
                });
            }

            checkPowerupCollection() {
                this.powerups = this.powerups.filter(powerup => {
                    // Check Player 1 collision
                    if (this.checkRectCollision(
                        { x: this.tankPosition.x, y: this.tankPosition.y, width: this.tankSize, height: this.tankSize },
                        powerup
                    )) {
                        this.collectPowerup(powerup, 'player1');
                        powerup.element.remove();
                        return false;
                    }
                    
                    // Check Player 2 collision (if two-player mode is active)
                    if (this.twoPlayerMode && this.checkRectCollision(
                        { x: this.tank2Position.x, y: this.tank2Position.y, width: this.tankSize, height: this.tankSize },
                        powerup
                    )) {
                        this.collectPowerup(powerup, 'player2');
                        powerup.element.remove();
                        return false;
                    }
                    
                    return true;
                });
            }

            collectPowerup(powerup, player = 'player1') {
                const powerupName = powerup.type.split('/').pop().split('.')[0];
                
                console.log(`${player === 'player1' ? 'Player 1' : 'Player 2'} collected power-up: ${powerupName}`);
                
                if (player === 'player1') {
                    // Only one power-up active at a time
                    this.currentPowerup = { type: powerup.type, name: powerupName };
                    
                    switch(powerupName) {
                        case 'star':
                            if (this.weaponLevel < this.maxWeaponLevel) {
                                this.weaponLevel++;
                                this.updateWeaponStatus();
                                console.log(`Player 1 weapon upgraded to level ${this.weaponLevel}`);
                            } else {
                                // Give points if max weapon level
                                this.score += 500;
                                this.scoreElement.textContent = `Score: ${this.score}`;
                                console.log('Player 1 max weapon level - bonus points awarded');
                            }
                            this.currentPowerup = null; // Star is instant effect
                            break;
                        case 'freeze':
                        case 'flame':
                        case 'missile':
                            // These are held until used
                            break;
                    }
                    
                    this.updatePowerupStatus();
                } else {
                    // Player 2 power-up collection
                    this.tank2CurrentPowerup = { type: powerup.type, name: powerupName };
                    
                    switch(powerupName) {
                        case 'star':
                            if (this.tank2WeaponLevel < this.maxWeaponLevel) {
                                this.tank2WeaponLevel++;
                                this.updateWeaponStatus2();
                                console.log(`Player 2 weapon upgraded to level ${this.tank2WeaponLevel}`);
                            } else {
                                // Give points if max weapon level
                                this.score2 += 500;
                                this.score2Element.textContent = `Player 2 Score: ${this.score2}`;
                                console.log('Player 2 max weapon level - bonus points awarded');
                            }
                            this.tank2CurrentPowerup = null; // Star is instant effect
                            break;
                        case 'freeze':
                        case 'flame':
                        case 'missile':
                            // These are held until used
                            break;
                    }
                    
                    // Update Player 2 displays separately (like Player 1)
                    this.updateWeaponStatus2();
                    this.updatePowerupStatus2();
                }
            }

            // SHOOTING SYSTEM (Enhanced)
            shoot() {
                const currentTime = Date.now();
                if (currentTime - this.lastShotTime < this.shotCooldown) {
                    return;
                }
                
                // Check if player already has an active shot (single-shot system)
                if (this.hasActiveShot) {
                    return;
                }
                
                this.lastShotTime = currentTime;
                
                // Check for special weapons
                if (this.currentPowerup) {
                    switch(this.currentPowerup.name) {
                        case 'missile':
                            this.playCannonSound(); // Missile uses cannon sound
                            this.fireMissile();
                            // Missile stays active until death
                            return;
                        case 'flame':
                            this.fireFlame(); // Uses flamethrower sound inside fireFlame()
                            // Flame stays active until death
                            return;
                        case 'freeze':
                            // Freeze works like flamethrower - multiple rapid shots
                            this.fireFreezeBlast(); // Uses freezethrower sound inside fireFreezeBlast()
                            return;
                    }
                }
                
                // Regular bullets - play cannon sound
                this.playCannonSound();
                this.fireRegularBullets();
            }

            fireRegularBullets() {
                const startPos = this.getBulletStartPosition();
                
                if (this.weaponLevel === 1) {
                    // Single shot
                    this.createBullet(startPos.x, startPos.y, this.tankDirection);
                } else if (this.weaponLevel === 2) {
                    // Double shot (parallel)
                    const offset = 15;
                    if (this.tankDirection === 'up' || this.tankDirection === 'down') {
                        this.createBullet(startPos.x - offset, startPos.y, this.tankDirection);
                        this.createBullet(startPos.x + offset, startPos.y, this.tankDirection);
                    } else {
                        this.createBullet(startPos.x, startPos.y - offset, this.tankDirection);
                        this.createBullet(startPos.x, startPos.y + offset, this.tankDirection);
                    }
                } else if (this.weaponLevel === 3) {
                    // Triple shot (forward spread)
                    const offset = 20;
                    
                    // Center bullet
                    this.createBullet(startPos.x, startPos.y, this.tankDirection);
                    
                    // Side bullets with slight offset but same direction
                    if (this.tankDirection === 'up' || this.tankDirection === 'down') {
                        // Horizontal spread for vertical movement
                        this.createBullet(startPos.x - offset, startPos.y, this.tankDirection);
                        this.createBullet(startPos.x + offset, startPos.y, this.tankDirection);
                    } else {
                        // Vertical spread for horizontal movement  
                        this.createBullet(startPos.x, startPos.y - offset, this.tankDirection);
                        this.createBullet(startPos.x, startPos.y + offset, this.tankDirection);
                    }
                }
            }

            createBullet(x, y, direction) {
                const bullet = document.createElement('div');
                bullet.className = 'bullet';
                bullet.innerHTML = '<img src="assists/sprits/bullet.png" alt="Bullet">';
                
                bullet.style.left = x + 'px';
                bullet.style.top = y + 'px';
                
                this.gameContainer.appendChild(bullet);
                
                this.bullets.push({
                    element: bullet,
                    x: x,
                    y: y,
                    direction: direction,
                    isPlayerBullet: true // Mark as player bullet for single-shot system
                });
                
                // Set hasActiveShot for single-shot system
                this.hasActiveShot = true;
            }

            fireMissile() {
                const missile = document.createElement('div');
                missile.className = 'missile';
                missile.innerHTML = '<img src="assists/sfx/missile.png" alt="Homing Missile">';
                
                const startPos = this.getBulletStartPosition();
                
                missile.style.left = startPos.x + 'px';
                missile.style.top = startPos.y + 'px';
                
                this.gameContainer.appendChild(missile);
                
                // Find nearest target (enemy or boss)
                let target = null;
                let minDistance = Infinity;
                
                [...this.enemies, ...(this.boss ? [this.boss] : [])].forEach(enemy => {
                    const distance = Math.sqrt(
                        Math.pow(enemy.x - startPos.x, 2) + 
                        Math.pow(enemy.y - startPos.y, 2)
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                        target = enemy;
                    }
                });
                
                this.missiles.push({
                    element: missile,
                    x: startPos.x,
                    y: startPos.y,
                    target: target,
                    isEnemyMissile: false,
                    crazyTimer: 0,
                    chaosX: 0,
                    chaosY: 0,
                    lastChaosTime: Date.now()
                });
            }

            fireFlame() {
                const startPos = this.getBulletStartPosition();
                
                // Play flamethrower sound
                this.playFlamethrowerSound();
                
                // Create multiple flame particles for realistic spread (HEAVILY BALANCED)
                const flameCount = 2; // Further reduced from 3 to 2 for better balance
                const spreadAngle = 15; // Further reduced from 25 to 15 degrees for much tighter spread
                
                for (let i = 0; i < flameCount; i++) {
                    setTimeout(() => {
                        const flame = document.createElement('div');
                        flame.className = 'flame';
                        
                        // Create animated flame using frame sequence flam1.png to flam8.png
                        const flameImg = document.createElement('img');
                        flameImg.src = 'assists/powers/flam1.png'; // Start with frame 1
                        flameImg.style.width = '100%';
                        flameImg.style.height = '100%';
                        flameImg.style.objectFit = 'contain';
                        flameImg.style.imageRendering = 'pixelated';
                        flameImg.alt = 'Flame';
                        
                        flame.appendChild(flameImg);
                        
                        // Random size variation for more realistic flames
                        const size = 25 + Math.random() * 15; // 25-40px
                        flame.style.width = size + 'px';
                        flame.style.height = size + 'px';
                        
                        // Calculate spread position
                        const angle = (i - (flameCount - 1) / 2) * (spreadAngle / (flameCount - 1));
                        const radians = (angle * Math.PI) / 180;
                        
                        let offsetX = 0, offsetY = 0;
                        const spread = 8; // Further reduced from 12 to 8 for much tighter spread
                        
                        // Apply spread based on tank direction
                        switch(this.tankDirection) {
                            case 'up':
                                offsetX = Math.sin(radians) * spread;
                                offsetY = -Math.cos(radians) * spread;
                                break;
                            case 'down':
                                offsetX = -Math.sin(radians) * spread;
                                offsetY = Math.cos(radians) * spread;
                                break;
                            case 'left':
                                offsetX = -Math.cos(radians) * spread;
                                offsetY = Math.sin(radians) * spread;
                                break;
                            case 'right':
                                offsetX = Math.cos(radians) * spread;
                                offsetY = -Math.sin(radians) * spread;
                                break;
                        }
                        
                        flame.style.left = (startPos.x + offsetX) + 'px';
                        flame.style.top = (startPos.y + offsetY) + 'px';
                        
                        this.gameContainer.appendChild(flame);
                        
                        this.flames.push({
                            element: flame,
                            img: flameImg,
                            x: startPos.x + offsetX,
                            y: startPos.y + offsetY,
                            direction: this.tankDirection,
                            maxRange: 80 + Math.random() * 20, // Further reduced range 80-100px (much shorter than freeze for balance)
                            traveled: 0,
                            currentFrame: 1, // Track animation frame
                            lastFrameTime: Date.now()
                        });
                        
                        if (i === 0) {
                            console.log('Multi-frame flame animation started (flam1-8.png)!');
                        }
                        
                    }, i * 120); // Much slower stagger for balance (120ms vs freeze's 60ms)
                }
            }

            fireFreezeBlast() {
                const startPos = this.getBulletStartPosition();
                
                // Play freezethrower sound
                this.playFreezeThrowerSound();
                
                // Create multiple freeze particles for realistic spread
                const freezeCount = 3; // Fewer than flame for different feel
                const spreadAngle = 25; // Slightly tighter spread than flame
                
                for (let i = 0; i < freezeCount; i++) {
                    setTimeout(() => {
                        const freeze = document.createElement('div');
                        freeze.className = 'freeze-blast';
                        
                        // Create animated freeze using frame sequence freeze1.png to freeze8.png
                        const freezeImg = document.createElement('img');
                        freezeImg.src = 'assists/powers/freeze1.png'; // Start with frame 1
                        freezeImg.style.width = '100%';
                        freezeImg.style.height = '100%';
                        freezeImg.style.objectFit = 'contain';
                        freezeImg.style.imageRendering = 'pixelated';
                        freezeImg.alt = 'Freeze Blast';
                        
                        freeze.appendChild(freezeImg);
                        
                        // Random size variation for more realistic freeze blasts
                        const size = 30 + Math.random() * 10; // 30-40px (slightly bigger than flame)
                        freeze.style.width = size + 'px';
                        freeze.style.height = size + 'px';
                        
                        // Calculate spread position
                        const angle = (i - (freezeCount - 1) / 2) * (spreadAngle / (freezeCount - 1));
                        const radians = (angle * Math.PI) / 180;
                        
                        let offsetX = 0, offsetY = 0;
                        const spread = 12; // Slightly tighter spread than flame
                        
                        // Apply spread based on tank direction
                        switch(this.tankDirection) {
                            case 'up':
                                offsetX = Math.sin(radians) * spread;
                                offsetY = -Math.cos(radians) * spread;
                                break;
                            case 'down':
                                offsetX = -Math.sin(radians) * spread;
                                offsetY = Math.cos(radians) * spread;
                                break;
                            case 'left':
                                offsetX = -Math.cos(radians) * spread;
                                offsetY = Math.sin(radians) * spread;
                                break;
                            case 'right':
                                offsetX = Math.cos(radians) * spread;
                                offsetY = -Math.sin(radians) * spread;
                                break;
                        }
                        
                        freeze.style.left = (startPos.x + offsetX) + 'px';
                        freeze.style.top = (startPos.y + offsetY) + 'px';
                        
                        this.gameContainer.appendChild(freeze);
                        
                        this.freezeBlasts.push({
                            element: freeze,
                            img: freezeImg,
                            x: startPos.x + offsetX,
                            y: startPos.y + offsetY,
                            direction: this.tankDirection,
                            maxRange: 140 + Math.random() * 50, // Longer range than flame (140-190px vs 120-160px)
                            traveled: 0,
                            currentFrame: 1, // Track animation frame
                            lastFrameTime: Date.now()
                        });
                        
                        if (i === 0) {
                            console.log('Multi-frame freeze animation started (freeze1-8.png)!');
                        }
                        
                    }, i * 60); // Slightly faster stagger than flame (60ms vs 50ms)
                }
            }

            getBulletStartPosition() {
                const tankCenter = {
                    x: this.tankPosition.x + 25,
                    y: this.tankPosition.y + 25
                };
                
                let bulletX = tankCenter.x - 6;
                let bulletY = tankCenter.y - 6;
                
                switch(this.tankDirection) {
                    case 'up':
                        bulletY = this.tankPosition.y - 12;
                        break;
                    case 'down':
                        bulletY = this.tankPosition.y + 62;
                        break;
                    case 'left':
                        bulletX = this.tankPosition.x - 12;
                        break;
                    case 'right':
                        bulletX = this.tankPosition.x + 62;
                        break;
                }

                return { x: bulletX, y: bulletY };
            }

            getBulletStartPosition2() {
                const tankCenter = {
                    x: this.tank2Position.x + 25,
                    y: this.tank2Position.y + 25
                };
                
                let bulletX = tankCenter.x - 6;
                let bulletY = tankCenter.y - 6;
                
                switch(this.tank2Direction) {
                    case 'up':
                        bulletY = this.tank2Position.y - 12;
                        break;
                    case 'down':
                        bulletY = this.tank2Position.y + 62;
                        break;
                    case 'left':
                        bulletX = this.tank2Position.x - 12;
                        break;
                    case 'right':
                        bulletX = this.tank2Position.x + 62;
                        break;
                }

                return { x: bulletX, y: bulletY };
            }

            // ENEMY SYSTEM (Enhanced - Multiple enemy types)
            spawnEnemies() {
                // COMMENTED OUT FOR TESTING - Use manual spawn buttons instead
                // this.enemies.forEach(enemy => enemy.element.remove());
                // this.enemies = [];
                // this.frozenEnemies.clear();
                // this.enemyHitPoints.clear();

                // for (let i = 0; i < this.maxEnemies; i++) {
                //     this.spawnEnemy();
                // }
                
                console.log('Auto enemy spawning disabled - use manual spawn buttons for testing');
            }

            spawnEnemy() {
                const enemy = document.createElement('div');
                enemy.className = 'enemy-tank';
                enemy.style.position = 'absolute';
                enemy.style.width = '50px';
                enemy.style.height = '50px';
                enemy.style.zIndex = '8';
                
                // Create tank body with random enemy type
                const tankBody = document.createElement('img');
                const randomEnemyType = this.enemyTypes[Math.floor(Math.random() * this.enemyTypes.length)];
                tankBody.src = randomEnemyType;
                tankBody.style.width = '100%';
                tankBody.style.height = '100%';
                tankBody.style.position = 'absolute';
                tankBody.style.objectFit = 'contain';
                tankBody.style.imageRendering = 'pixelated';
                tankBody.alt = ''; // Remove alt text to prevent "Enemy Tank" text from showing
                
                // Assemble tank (no wheels for enemies)
                enemy.appendChild(tankBody);
                
                let x, y;
                let attempts = 0;
                do {
                    x = Math.random() * (this.containerWidth - this.tankSize);
                    y = Math.random() * (this.containerHeight - this.tankSize);
                    attempts++;
                    if (attempts > 50) {
                        console.log('Using fallback spawn position');
                        break;
                    }
                } while (Math.sqrt(Math.pow(x - this.tankPosition.x, 2) + Math.pow(y - this.tankPosition.y, 2)) < 150);
                
                enemy.style.left = x + 'px';
                enemy.style.top = y + 'px';
                
                console.log(`Enemy spawned at (${Math.round(x)}, ${Math.round(y)})`);
                this.gameContainer.appendChild(enemy);
                
                const enemyData = {
                    element: enemy,
                    body: tankBody,
                    x: x,
                    y: y,
                    direction: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
                    lastDirection: Date.now(),
                    lastShot: 0,
                    hasActiveShot: false,
                    id: Date.now() + Math.random(),
                    isBigTank: false,
                    size: 50,
                    enemyType: randomEnemyType
                };
                
                this.enemies.push(enemyData);
                this.enemyHitPoints.set(enemyData.id, 4); // 4 hits to destroy regular enemies
                this.updateEnemyRotation(enemyData);
                
                console.log('Regular enemy spawned:', randomEnemyType.split('/').pop());
            }

            spawnEnemyGroup() {
                console.log('Spawning enemy group...');
                console.log(`Current state: killed=${this.enemiesKilled}, currentCount=${this.currentEnemyCount}, bossSpawned=${this.bossSpawned}`);
                
                // STRICT BLOCKING: Don't spawn if we've reached kill limit or boss is spawned or too many enemies exist
                if (this.enemiesKilled >= this.maxEnemiesBeforeBoss || this.bossSpawned || this.currentEnemyCount >= this.maxEnemies) {
                    console.log('SPAWN BLOCKED - reached limit or boss spawned');
                    console.log(`Reason: killed=${this.enemiesKilled}/${this.maxEnemiesBeforeBoss}, boss=${this.bossSpawned}, count=${this.currentEnemyCount}/${this.maxEnemies}`);
                    return;
                }
                
                // ADDITIONAL SAFETY: Don't spawn more if we would exceed the kill limit
                // Only block if spawning would definitely exceed 19 total kills
                if (this.enemiesKilled >= this.maxEnemiesBeforeBoss) {
                    console.log('SPAWN BLOCKED - already reached kill limit');
                    console.log(`Already killed ${this.enemiesKilled}/${this.maxEnemiesBeforeBoss} enemies`);
                    return;
                }
                
                // Calculate how many enemies to spawn - ensure we maintain 3 on screen until boss
                let enemiesToSpawn;
                if (this.currentEnemyCount === 0) {
                    // No enemies on screen - spawn up to 3
                    enemiesToSpawn = Math.min(3, this.maxEnemies);
                } else {
                    // Some enemies on screen - spawn enough to reach 3 total
                    enemiesToSpawn = Math.min(
                        this.maxEnemies - this.currentEnemyCount,
                        3 - this.currentEnemyCount
                    );
                }
                
                console.log(`Spawning ${enemiesToSpawn} enemies (current: ${this.currentEnemyCount}/${this.maxEnemies}, killed: ${this.enemiesKilled}/${this.maxEnemiesBeforeBoss})`);
                
                if (enemiesToSpawn <= 0) {
                    console.log('No enemies to spawn - screen is full');
                    return;
                }
                
                for (let i = 0; i < enemiesToSpawn; i++) {
                    this.spawnEnemy();
                    this.currentEnemyCount++;
                }
                
                // Update enemy counter display
                this.updateLivesDisplay();
                console.log('Enemy group spawn complete');
            }

            spawnBigTank() {
                const bigEnemy = document.createElement('div');
                bigEnemy.className = 'big-enemy-tank';
                bigEnemy.style.position = 'absolute';
                bigEnemy.style.width = '80px';
                bigEnemy.style.height = '80px';
                bigEnemy.style.zIndex = '9';
                
                // Create tank body (static)
                const tankBody = document.createElement('img');
                tankBody.src = 'assists/sprits/tank-blue.png'; // Changed from big-tank.png to tank-blue.png
                tankBody.style.width = '100%';
                tankBody.style.height = '100%';
                tankBody.style.position = 'absolute';
                tankBody.style.objectFit = 'contain';
                tankBody.style.imageRendering = 'pixelated';
                tankBody.alt = 'Big Enemy Tank';
                
                // Assemble tank (no wheels for enemies)
                bigEnemy.appendChild(tankBody);
                
                // Position randomly away from player
                let x, y;
                do {
                    x = Math.random() * (this.containerWidth - 80);
                    y = Math.random() * (this.containerHeight - 80);
                } while (Math.sqrt(Math.pow(x - this.tankPosition.x, 2) + Math.pow(y - this.tankPosition.y, 2)) < 200);
                
                bigEnemy.style.left = x + 'px';
                bigEnemy.style.top = y + 'px';
                
                this.gameContainer.appendChild(bigEnemy);
                
                const bigEnemyData = {
                    element: bigEnemy,
                    body: tankBody,
                    x: x,
                    y: y,
                    direction: ['up', 'down', 'left', 'right'][Math.floor(Math.random() * 4)],
                    lastDirection: Date.now(),
                    lastShot: 0,
                    hasActiveShot: false,
                    id: Date.now() + Math.random(),
                    size: 80, // Bigger than regular enemies
                    // Enhanced stats
                    moveSpeed: 0.7, // Slower than regular enemies
                    fireRate: 3000, // Shoots less frequently
                    isBigTank: true
                };
                
                this.enemies.push(bigEnemyData);
                this.enemyHitPoints.set(bigEnemyData.id, 6); // 6 hits to destroy
                this.updateEnemyRotation(bigEnemyData);
                
                console.log('Big Enemy Tank spawned - 6 hits to destroy, no wheels!');
            }

            updateEnemyRotation(enemy) {
                let rotation = 0;
                switch(enemy.direction) {
                    case 'up': 
                        rotation = 180;    // Match player tank rotation
                        break;
                    case 'right': 
                        rotation = 270;    // Match player tank rotation
                        break;
                    case 'down': 
                        rotation = 0;      // Match player tank rotation
                        break;
                    case 'left': 
                        rotation = 90;     // Match player tank rotation
                        break;
                }
                
                enemy.element.style.transform = `rotate(${rotation}deg)`;
            }

            updateEnemies() {
                const currentTime = Date.now();
                
                this.enemies.forEach(enemy => {
                    const isFrozen = this.frozenEnemies.has(enemy.id);
                    
                    if (isFrozen) {
                        return; // Skip movement and shooting for frozen enemies
                    }
                    
                    /* SIMPLIFIED MOVEMENT - Like players (no curving) */
                    // Change direction less frequently for straighter movement
                    if (currentTime - enemy.lastDirection > 2000) { // Change direction every 2 seconds
                        const directions = ['up', 'down', 'left', 'right'];
                        enemy.direction = directions[Math.floor(Math.random() * directions.length)];
                        this.updateEnemyRotation(enemy);
                        enemy.lastDirection = currentTime;
                    }
                    
                    // Simple, direct movement like players - no complex AI
                    let newX = enemy.x;
                    let newY = enemy.y;
                    let enemySpeed = enemy.isBigTank ? enemy.moveSpeed : this.enemySpeed;
                    
                    switch(enemy.direction) {
                        case 'up':
                            newY -= enemySpeed;
                            break;
                        case 'down':
                            newY += enemySpeed;
                            break;
                        case 'left':
                            newX -= enemySpeed;
                            break;
                        case 'right':
                            newX += enemySpeed;
                            break;
                    }
                    
                    // Keep enemy in bounds (adjust for size)
                    const enemySize = enemy.size || this.tankSize;
                    if (newX >= 0 && newX <= this.containerWidth - enemySize &&
                        newY >= 0 && newY <= this.containerHeight - enemySize) {
                        enemy.x = newX;
                        enemy.y = newY;
                        enemy.element.style.left = enemy.x + 'px';
                        enemy.element.style.top = enemy.y + 'px';
                    } else {
                        // Hit boundary - change direction immediately (like bouncing)
                        const directions = ['up', 'down', 'left', 'right'];
                        enemy.direction = directions[Math.floor(Math.random() * directions.length)];
                        this.updateEnemyRotation(enemy);
                        enemy.lastDirection = currentTime;
                    }
                    
                    // Simple shooting logic
                    const fireRate = enemy.isBigTank ? enemy.fireRate : this.enemyShootInterval;
                    if (currentTime - enemy.lastShot > fireRate && !enemy.hasActiveShot) {
                        this.enemyShoot(enemy);
                        enemy.lastShot = currentTime;
                    }
                });
            }

            enemyShoot(enemy) {
                if (enemy.hasActiveShot) return;
                
                this.playCannonSound();
                
                const bullet = document.createElement('div');
                bullet.className = 'enemy-bullet';
                bullet.innerHTML = '<img src="assists/sprits/bullet.png" alt="Bullet">';
                
                const bulletPos = this.getBulletStartPositionForEnemy(enemy);
                bullet.style.left = bulletPos.x + 'px';
                bullet.style.top = bulletPos.y + 'px';
                
                this.gameContainer.appendChild(bullet);
                enemy.hasActiveShot = true;
                
                this.enemyBullets.push({
                    element: bullet,
                    x: bulletPos.x,
                    y: bulletPos.y,
                    direction: enemy.direction,
                    enemyId: enemy.id
                });
            }

            getBulletStartPositionForEnemy(enemy) {
                const enemyCenter = {
                    x: enemy.x + 25,
                    y: enemy.y + 25
                };
                
                let bulletX = enemyCenter.x - 6;
                let bulletY = enemyCenter.y - 6;
                
                switch(enemy.direction) {
                    case 'up':
                        bulletY = enemy.y - 12;
                        break;
                    case 'down':
                        bulletY = enemy.y + 62;
                        break;
                    case 'left':
                        bulletX = enemy.x - 12;
                        break;
                    case 'right':
                        bulletX = enemy.x + 62;
                        break;
                }
                
                return { x: bulletX, y: bulletY };
            }

            handleEnemyHit(enemy, player = 'player1') {
                const currentHits = this.enemyHitPoints.get(enemy.id) || 4;
                const newHits = currentHits - 1;
                this.enemyHitPoints.set(enemy.id, newHits);
                
                // Visual hit feedback
                enemy.element.classList.add('hit');
                setTimeout(() => {
                    if (enemy.element) {
                        enemy.element.classList.remove('hit');
                    }
                }, 300);
                
                console.log(`Enemy hit by ${player}! Hits remaining: ${newHits}`);
                
                if (newHits <= 0) {
                    // Enemy destroyed
                    console.log(`Enemy destroyed by ${player}!`);
                    this.playExplodeSound();
                    
                    // Create destroy effect at enemy position
                    this.createDestroyEffect(enemy.x, enemy.y);
                    
                    // Award points to the correct player
                    if (player === 'player2') {
                        this.score2 += 100;
                        this.score2Element.textContent = `Player 2 Score: ${this.score2}`;
                    } else {
                        this.score += 100;
                        this.scoreElement.textContent = `Score: ${this.score}`;
                    }
                    
                    // Visual destruction effect
                    this.gameContainer.style.background = '#004400';
                    setTimeout(() => {
                        this.gameContainer.style.background = '#1a1a1a';
                    }, 200);
                    
                    // Clean up any effects on this enemy
                    if (this.burningTanks.has(enemy.id)) {
                        this.burningTanks.get(enemy.id).effectElement.remove();
                        this.burningTanks.delete(enemy.id);
                    }
                    if (this.frozenEffects.has(enemy.id)) {
                        this.frozenEffects.get(enemy.id).effectElement.remove();
                        this.frozenEffects.delete(enemy.id);
                    }
                    
                    // Remove enemy
                    const enemyIndex = this.enemies.indexOf(enemy);
                    if (enemyIndex > -1) {
                        this.enemies.splice(enemyIndex, 1);
                        this.frozenEnemies.delete(enemy.id);
                        this.enemyHitPoints.delete(enemy.id);
                        enemy.element.remove();
                        
                        // Increment kill counter
                        this.enemiesKilled++;
                        this.currentEnemyCount--;
                        this.updateLivesDisplay();
                        
                        console.log(`Enemy killed! Total: ${this.enemiesKilled}/${this.maxEnemiesBeforeBoss}`);
                        
                        // Check if we should spawn the boss
                        if (this.enemiesKilled >= this.maxEnemiesBeforeBoss && !this.bossSpawned) {
                            console.log(`19 enemies killed! Clearing remaining enemies and preparing boss fight...`);
                            this.bossSpawned = true; // Set immediately to prevent multiple boss spawns
                            
                            // Clear all remaining enemies on screen
                            this.enemies.forEach(enemy => {
                                if (enemy.element) {
                                    enemy.element.remove();
                                }
                            });
                            this.enemies = [];
                            this.currentEnemyCount = 0;
                            console.log('All remaining enemies cleared for boss fight');
                            
                            // Play boss music first
                            console.log('Playing boss music...');
                            this.playBossMusic();
                            
                            // Spawn boss after music plays for 5 seconds
                            setTimeout(() => {
                                console.log('Boss music has been playing for 5 seconds - spawning boss now!');
                                this.spawnBoss();
                            }, 5000); // 5 second delay after music starts
                        } else if (!this.bossSpawned && this.enemiesKilled < this.maxEnemiesBeforeBoss) {
                            // Only spawn new enemies if we haven't reached the boss threshold yet
                            setTimeout(() => {
                                if (this.currentEnemyCount < this.maxEnemies && this.enemiesKilled < this.maxEnemiesBeforeBoss) {
                                    this.spawnEnemyGroup();
                                }
                            }, 2000);
                        }
                    }
                } else {
                    // Enemy damaged but not destroyed
                    if (player === 'player2') {
                        this.score2 += 25;
                        this.score2Element.textContent = `Player 2 Score: ${this.score2}`;
                    } else {
                        this.score += 25;
                        this.scoreElement.textContent = `Score: ${this.score}`;
                    }
                }
            }

            handlePlayerHit() {
                // Skip damage if infinite health cheat is active
                if (this.infiniteHealth) {
                    console.log('Player hit but infinite health is active');
                    return;
                }
                
                console.log('Player 1 hit!');
                this.playExplodeSound();
                
                // Reduce lives
                this.player1Lives--;
                this.updateLivesDisplay();
                
                console.log(`Player 1 lives remaining: ${this.player1Lives}`);
                
                // Check for game over
                if (this.player1Lives <= 0) {
                    console.log('Player 1 out of lives! Game Over!');
                    this.gameOver = true;
                    setTimeout(() => {
                        this.showGameOverScreen('Player 1');
                    }, 1000);
                    return;
                }
                
                // Create destroy effect at player position
                this.createDestroyEffect(this.tankPosition.x, this.tankPosition.y);
                
                // Clean up any effects on player
                if (this.burningTanks.has('player')) {
                    this.burningTanks.get('player').effectElement.remove();
                    this.burningTanks.delete('player');
                }
                if (this.frozenEffects.has('player')) {
                    this.frozenEffects.get('player').effectElement.remove();
                    this.frozenEffects.delete('player');
                }
                
                // Reset player position
                this.tankPosition = { x: 100, y: 200 };
                this.updateTankPosition();
                
                // Visual feedback
                this.gameContainer.style.background = '#440000';
                setTimeout(() => {
                    this.gameContainer.style.background = '#1a1a1a';
                }, 200);
            }

            handlePlayer2Hit() {
                // Skip damage if infinite health cheat is active or not in two-player mode
                if (this.infiniteHealth || !this.twoPlayerMode) {
                    console.log('Player 2 hit but infinite health is active or single player mode');
                    return;
                }
                
                console.log('Player 2 hit!');
                this.playExplodeSound();
                
                // Reduce lives
                this.player2Lives--;
                this.updateLivesDisplay();
                
                console.log(`Player 2 lives remaining: ${this.player2Lives}`);
                
                // Check for game over
                if (this.player2Lives <= 0) {
                    console.log('Player 2 out of lives!');
                    // In two-player mode, continue if player 1 still has lives
                    if (this.player1Lives <= 0) {
                        console.log('Both players out of lives! Game Over!');
                        this.gameOver = true;
                        setTimeout(() => {
                            this.showGameOverScreen('Both Players');
                        }, 1000);
                        return;
                    }
                }
                
                // Create destroy effect at player 2 position
                this.createDestroyEffect(this.tank2Position.x, this.tank2Position.y);
                
                // Clean up any effects on player 2
                if (this.burningTanks.has('player2')) {
                    this.burningTanks.get('player2').effectElement.remove();
                    this.burningTanks.delete('player2');
                }
                if (this.frozenEffects.has('player2')) {
                    this.frozenEffects.get('player2').effectElement.remove();
                    this.frozenEffects.delete('player2');
                }
                
                // Reset player 2 position
                this.tank2Position = { x: 200, y: 400 };
                this.updateTank2Position();
                
                // Visual feedback
                this.gameContainer.style.background = '#440000';
                setTimeout(() => {
                    this.gameContainer.style.background = '#1a1a1a';
                }, 200);
            }

            // ENHANCED CONTROLS
            setupControls() {
                // D-pad controls
                const dpadButtons = document.querySelectorAll('.dpad-button');
                dpadButtons.forEach(button => {
                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const direction = button.dataset.direction;
                        if (direction) {
                            this.handleDirectionPress(direction);
                            button.classList.add('button-pressed');
                        }
                    });

                    button.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        const direction = button.dataset.direction;
                        if (direction) {
                            this.handleDirectionRelease(direction);
                            button.classList.remove('button-pressed');
                        }
                    });

                    button.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        const direction = button.dataset.direction;
                        if (direction) {
                            this.handleDirectionPress(direction);
                            button.classList.add('button-pressed');
                        }
                    });

                    button.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        const direction = button.dataset.direction;
                        if (direction) {
                            this.handleDirectionRelease(direction);
                            button.classList.remove('button-pressed');
                        }
                    });
                });

                // Action buttons
                const shootButton = document.getElementById('shootButton');
                shootButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.shoot();
                    shootButton.classList.add('shoot-pressed');
                    setTimeout(() => shootButton.classList.remove('shoot-pressed'), 150);
                });

                shootButton.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.shoot();
                    shootButton.classList.add('shoot-pressed');
                    setTimeout(() => shootButton.classList.remove('shoot-pressed'), 150);
                });

                // Stage button
                const stageButton = document.getElementById('stageButton');
                stageButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.nextStage();
                    stageButton.classList.add('test-pressed');
                    setTimeout(() => stageButton.classList.remove('test-pressed'), 150);
                });

                stageButton.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.nextStage();
                    stageButton.classList.add('test-pressed');
                    setTimeout(() => stageButton.classList.remove('test-pressed'), 150);
                });

                // Power-up spawn button
                const powerupButton = document.getElementById('powerupButton');
                powerupButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.spawnRandomPowerup();
                    powerupButton.classList.add('test-pressed');
                    setTimeout(() => powerupButton.classList.remove('test-pressed'), 150);
                });

                powerupButton.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.spawnRandomPowerup();
                    powerupButton.classList.add('test-pressed');
                    setTimeout(() => powerupButton.classList.remove('test-pressed'), 150);
                });

                // Boss spawn button
                const bossButton = document.getElementById('bossButton');
                bossButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.spawnBoss();
                    bossButton.classList.add('test-pressed');
                    setTimeout(() => bossButton.classList.remove('test-pressed'), 150);
                });

                bossButton.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.spawnBoss();
                    bossButton.classList.add('test-pressed');
                    setTimeout(() => bossButton.classList.remove('test-pressed'), 150);
                });

                // Enemy spawn button listeners
                const enemyButton = document.getElementById('enemyButton');
                enemyButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.spawnEnemyGroup();
                    enemyButton.classList.add('test-pressed');
                    setTimeout(() => enemyButton.classList.remove('test-pressed'), 150);
                });

                enemyButton.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.spawnEnemyGroup();
                    enemyButton.classList.add('test-pressed');
                    setTimeout(() => enemyButton.classList.remove('test-pressed'), 150);
                });

                // Big Tank spawn button listeners
                const bigTankButton = document.getElementById('bigTankButton');
                bigTankButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.spawnBigTank();
                    bigTankButton.classList.add('test-pressed');
                    setTimeout(() => bigTankButton.classList.remove('test-pressed'), 150);
                });

                bigTankButton.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.spawnBigTank();
                    bigTankButton.classList.add('test-pressed');
                    setTimeout(() => bigTankButton.classList.remove('test-pressed'), 150);
                });

                // Two-Player Mode Toggle
                const twoPlayerButton = document.getElementById('twoPlayerButton');
                twoPlayerButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.toggleTwoPlayerMode();
                    twoPlayerButton.classList.add('test-pressed');
                    setTimeout(() => twoPlayerButton.classList.remove('test-pressed'), 150);
                });

                twoPlayerButton.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.toggleTwoPlayerMode();
                    twoPlayerButton.classList.add('test-pressed');
                    setTimeout(() => twoPlayerButton.classList.remove('test-pressed'), 150);
                });

                // Xbox Controller Support
                this.setupGamepadSupport();

                // Controls toggle functionality
                this.controlsToggle.addEventListener('click', () => {
                    this.controls.classList.toggle('hidden');
                    this.controlsToggle.textContent = this.controls.classList.contains('hidden') 
                        ? 'Show Controls' 
                        : 'Hide Controls';
                });

                // Enhanced keyboard controls (Player 1 + Player 2 + Xbox controller)
                document.addEventListener('keydown', (e) => {
                    let direction = null;
                    let player2Direction = null;
                    
                    // Player 1 controls (WASD + Arrow Keys)
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            direction = 'up';
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            direction = 'down';
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            direction = 'left';
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            direction = 'right';
                            break;
                        case ' ':
                        case 'Enter':
                            e.preventDefault();
                            this.shoot();
                            return;
                    }
                    
                    // Player 2 controls (IJKL keys) - only in two-player mode
                    if (this.twoPlayerMode) {
                        switch(e.key) {
                            case 'i':
                            case 'I':
                                player2Direction = 'up';
                                break;
                            case 'k':
                            case 'K':
                                player2Direction = 'down';
                                break;
                            case 'j':
                            case 'J':
                                player2Direction = 'left';
                                break;
                            case 'l':
                            case 'L':
                                player2Direction = 'right';
                                break;
                            case 'Shift': // Right Shift for Player 2 shooting
                                if (e.location === KeyboardEvent.DOM_KEY_LOCATION_RIGHT) {
                                    e.preventDefault();
                                    this.shoot2();
                                    return;
                                }
                                break;
                        }
                    }
                    
                    // Game controls (available for both players)
                    switch(e.key) {
                        case 'p':
                        case 'P':
                            e.preventDefault();
                            this.spawnRandomPowerup();
                            return;
                        case 'b':
                        case 'B':
                            e.preventDefault();
                            this.spawnBoss();
                            return;
                        case 'n':
                        case 'N':
                            e.preventDefault();
                            this.nextStage();
                            return;
                        case 'm':
                        case 'M':
                            e.preventDefault();
                            this.audioControls.click();
                            return;
                        case 't':
                        case 'T':
                            e.preventDefault();
                            this.toggleTwoPlayerMode();
                            return;
                    }
                    
                    if (direction) {
                        e.preventDefault();
                        this.handleDirectionPress(direction);
                    }
                    
                    if (player2Direction && this.twoPlayerMode) {
                        e.preventDefault();
                        this.handleDirectionPress2(player2Direction);
                    }
                });

                document.addEventListener('keyup', (e) => {
                    let direction = null;
                    let player2Direction = null;
                    
                    // Player 1 controls
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            direction = 'up';
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            direction = 'down';
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            direction = 'left';
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            direction = 'right';
                            break;
                    }
                    
                    // Player 2 controls (IJKL keys) - only in two-player mode
                    if (this.twoPlayerMode) {
                        switch(e.key) {
                            case 'i':
                            case 'I':
                                player2Direction = 'up';
                                break;
                            case 'k':
                            case 'K':
                                player2Direction = 'down';
                                break;
                            case 'j':
                            case 'J':
                                player2Direction = 'left';
                                break;
                            case 'l':
                            case 'L':
                                player2Direction = 'right';
                                break;
                        }
                    }
                    
                    if (direction) {
                        this.handleDirectionRelease(direction);
                    }
                    
                    if (player2Direction && this.twoPlayerMode) {
                        this.handleDirectionRelease2(player2Direction);
                    }
                });

                window.addEventListener('resize', () => {
                    this.containerWidth = window.innerWidth;
                    this.containerHeight = window.innerHeight * 0.8; // Updated for bigger screen
                });
            }

            // MOVEMENT (No sliding, snappy movement)
            handleDirectionPress(direction) {
                // SIMPLIFIED DIRECTION HANDLING - Direct and responsive
                this.tankDirection = direction;      // Always update tank direction
                this.updateTankRotation();           // Always update rotation
                this.currentDirection = direction;   // Set movement direction
                this.pressedKeys.add(direction);     // Track pressed keys
            }

            handleDirectionRelease(direction) {
                // SIMPLIFIED RELEASE HANDLING
                this.pressedKeys.delete(direction);
                
                // Stop movement if releasing the current direction
                if (this.currentDirection === direction) {
                    this.currentDirection = null;
                    this.isMoving = false;
                }
            }

            updateTankRotation() {
                let rotation = 0;
                
                // FIXED TANK ROTATION - Swap directions to match sprite orientation
                switch(this.tankDirection) {
                    case 'up': 
                        rotation = 180;    // Was 0, now 180 (swap up/down)
                        break;
                    case 'right': 
                        rotation = 270;    // Was 90, now 270 (swap right/left)
                        break;
                    case 'down': 
                        rotation = 0;      // Was 180, now 0 (swap up/down)
                        break;
                    case 'left': 
                        rotation = 90;     // Was 270, now 90 (swap right/left)
                        break;
                }
                
                this.tank.style.transform = `rotate(${rotation}deg)`;
            }

            moveTank() {
                // RESET TO SIMPLE MOVEMENT - Comment out complex logic
                if (!this.currentDirection) {
                    this.isMoving = false;
                    return;
                }

                let newX = this.tankPosition.x;
                let newY = this.tankPosition.y;

                // Simple, direct movement without complex calculations
                switch(this.currentDirection) {
                    case 'up':
                        newY -= this.tankSpeed;
                        break;
                    case 'down':
                        newY += this.tankSpeed;
                        break;
                    case 'left':
                        newX -= this.tankSpeed;
                        break;
                    case 'right':
                        newX += this.tankSpeed;
                        break;
                }

                // Simple boundary check - keep tank in bounds
                if (newX >= 0 && newX <= this.containerWidth - this.tankSize &&
                    newY >= 0 && newY <= this.containerHeight - this.tankSize) {
                    
                    // SIMPLIFIED: Just update position and mark as moving
                    this.tankPosition.x = newX;
                    this.tankPosition.y = newY;
                    this.updateTankPosition();
                    this.isMoving = true; // Keep wheels spinning when moving
                } else {
                    this.isMoving = false; // Stop wheels at boundaries
                }

                // Check power-up collection
                this.checkPowerupCollection();
            }

            updateTankPosition() {
                this.tank.style.left = this.tankPosition.x + 'px';
                this.tank.style.top = this.tankPosition.y + 'px';
                
                // Update player tank wheel animation when moving
                if (this.isMoving) {
                    this.updatePlayerWheelAnimation();
                }
            }

            updatePlayerWheelAnimation() {
                const now = Date.now();
                if (now - this.lastPlayerWheelUpdate > 90) { // Faster animation for player (90ms per frame)
                    this.playerWheelFrame = (this.playerWheelFrame % 6) + 1; // Use all 6 frames for player
                    
                    // Player uses all wheel frames for maximum visual impact
                    const wheelSrc = `assists/sprits/wheels${this.playerWheelFrame}.png`;
                    
                    this.tankLeftWheel.src = wheelSrc;
                    this.tankRightWheel.src = wheelSrc;
                    
                    this.lastPlayerWheelUpdate = now;
                }
            }

            // PLAYER 2 SUPPORT METHODS
            toggleTwoPlayerMode() {
                this.twoPlayerMode = !this.twoPlayerMode;
                const button = document.getElementById('twoPlayerButton');
                
                if (this.twoPlayerMode) {
                    // Enable Player 2
                    this.tank2.style.display = 'block';
                    this.score2Element.style.display = 'block';
                    this.powerupStatus2.style.display = 'block';
                    this.weaponStatus2.style.display = 'block';
                    button.innerHTML = '2 PLAYERS<br>ON';
                    button.classList.add('active');
                    this.updateTank2Position();
                    this.updateWeaponStatus2();
                    this.updatePowerupStatus2();
                    console.log('Two-player mode ENABLED');
                } else {
                    // Disable Player 2
                    this.tank2.style.display = 'none';
                    this.score2Element.style.display = 'none';
                    this.powerupStatus2.style.display = 'none';
                    this.weaponStatus2.style.display = 'none';
                    button.innerHTML = '2 PLAYERS<br>OFF';
                    button.classList.remove('active');
                    console.log('Two-player mode DISABLED');
                }
            }

            // Player 2 Movement Handlers
            handleDirectionPress2(direction) {
                this.tank2Direction = direction;
                this.updateTank2Rotation();
                this.tank2CurrentDirection = direction;
                this.tank2PressedKeys.add(direction);
            }

            handleDirectionRelease2(direction) {
                this.tank2PressedKeys.delete(direction);
                if (this.tank2CurrentDirection === direction) {
                    this.tank2CurrentDirection = null;
                    this.tank2IsMoving = false;
                }
            }

            updateTank2Rotation() {
                let rotation = 0;
                // Same rotation system as Player 1 (sprite fixes applied)
                switch(this.tank2Direction) {
                    case 'up': 
                        rotation = 180;
                        break;
                    case 'right': 
                        rotation = 270;
                        break;
                    case 'down': 
                        rotation = 0;
                        break;
                    case 'left': 
                        rotation = 90;
                        break;
                }
                this.tank2.style.transform = `rotate(${rotation}deg)`;
            }

            moveTank2() {
                if (!this.tank2CurrentDirection) {
                    this.tank2IsMoving = false;
                    return;
                }

                let newX = this.tank2Position.x;
                let newY = this.tank2Position.y;

                switch(this.tank2CurrentDirection) {
                    case 'up':
                        newY -= this.tank2Speed;
                        break;
                    case 'down':
                        newY += this.tank2Speed;
                        break;
                    case 'left':
                        newX -= this.tank2Speed;
                        break;
                    case 'right':
                        newX += this.tank2Speed;
                        break;
                }

                // Boundary checks
                if (newX >= 0 && newX <= this.containerWidth - 50 &&
                    newY >= 0 && newY <= this.containerHeight - 50) {
                    this.tank2Position.x = newX;
                    this.tank2Position.y = newY;
                    this.tank2IsMoving = true;
                    this.updateTank2Position();
                }

                // Check power-up collection for Player 2
                this.checkPowerupCollection();
            }

            updateTank2Position() {
                if (this.tank2) {
                    this.tank2.style.left = this.tank2Position.x + 'px';
                    this.tank2.style.top = this.tank2Position.y + 'px';
                }
            }

            // Player 2 Shooting
            shoot2() {
                if (!this.twoPlayerMode) return;
                
                const currentTime = Date.now();
                if (currentTime - this.tank2LastShotTime < this.shotCooldown) return;

                // Check if player 2 already has an active shot (single-shot system)
                if (this.tank2HasActiveShot) {
                    return;
                }

                this.tank2LastShotTime = currentTime;
                
                // Check for special weapons (same logic as Player 1)
                if (this.tank2CurrentPowerup) {
                    switch(this.tank2CurrentPowerup.name) {
                        case 'missile':
                            this.playCannonSound(); // Missile uses cannon sound
                            this.fireMissile2();
                            // Missile stays active until death
                            return;
                        case 'flame':
                            this.fireFlame2(); // Uses flamethrower sound inside fireFlame2()
                            // Flame stays active until death
                            return;
                        case 'freeze':
                            // Freeze works like flamethrower - multiple rapid shots
                            this.fireFreezeBlast2(); // Uses freezethrower sound inside fireFreezeBlast2()
                            return;
                    }
                }
                
                // Regular bullets - play cannon sound
                this.playCannonSound();
                this.fireRegularBullets2();
            }

            fireRegularBullets2() {
                const currentTime = Date.now();
                const startPos = this.getBulletStartPosition2(); // Use proper positioning like P1
                
                if (this.tank2WeaponLevel === 1) {
                    this.createBullet2(startPos.x, startPos.y, this.tank2Direction);
                } else if (this.tank2WeaponLevel === 2) {
                    // Double shot with proper offset calculation
                    const offset = (this.tank2Direction === 'up' || this.tank2Direction === 'down') ? 5 : 5;
                    if (this.tank2Direction === 'up' || this.tank2Direction === 'down') {
                        this.createBullet2(startPos.x - offset, startPos.y, this.tank2Direction);
                        this.createBullet2(startPos.x + offset, startPos.y, this.tank2Direction);
                    } else {
                        this.createBullet2(startPos.x, startPos.y - offset, this.tank2Direction);
                        this.createBullet2(startPos.x, startPos.y + offset, this.tank2Direction);
                    }
                } else if (this.tank2WeaponLevel === 3) {
                    // Triple shot with proper offset calculation
                    const offset = (this.tank2Direction === 'up' || this.tank2Direction === 'down') ? 8 : 8;
                    this.createBullet2(startPos.x, startPos.y, this.tank2Direction);
                    if (this.tank2Direction === 'up' || this.tank2Direction === 'down') {
                        this.createBullet2(startPos.x - offset, startPos.y, this.tank2Direction);
                        this.createBullet2(startPos.x + offset, startPos.y, this.tank2Direction);
                    } else {
                        this.createBullet2(startPos.x, startPos.y - offset, this.tank2Direction);
                        this.createBullet2(startPos.x, startPos.y + offset, this.tank2Direction);
                    }
                }
                this.playCannonSound();
            }

            createBullet2(x, y, direction) {
                const bullet = document.createElement('div');
                bullet.className = 'bullet';
                bullet.style.position = 'absolute';
                bullet.style.width = '8px';
                bullet.style.height = '8px';
                bullet.style.backgroundColor = '#00ffff'; // Cyan bullets for Player 2
                bullet.style.borderRadius = '50%';
                bullet.style.left = x + 'px';
                bullet.style.top = y + 'px';
                bullet.style.zIndex = '5';
                
                this.gameContainer.appendChild(bullet);
                
                this.bullets.push({
                    element: bullet,
                    x: x,
                    y: y,
                    direction: direction,
                    isPlayer2: true
                });
                
                // Set tank2HasActiveShot for single-shot system
                this.tank2HasActiveShot = true;
            }

            // Player 2 Special Weapons (similar to Player 1)
            fireMissile2() {
                const missile = document.createElement('div');
                missile.className = 'missile';
                missile.innerHTML = '<img src="assists/sfx/missile.png" alt="Player 2 Homing Missile">';
                
                const startPos = this.getBulletStartPosition2();
                
                missile.style.left = startPos.x + 'px';
                missile.style.top = startPos.y + 'px';
                
                this.gameContainer.appendChild(missile);
                
                // Find nearest target (enemy or boss)
                let target = null;
                let minDistance = Infinity;
                
                [...this.enemies, ...(this.boss ? [this.boss] : [])].forEach(enemy => {
                    const distance = Math.sqrt(
                        Math.pow(enemy.x - startPos.x, 2) + 
                        Math.pow(enemy.y - startPos.y, 2)
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                        target = enemy;
                    }
                });
                
                this.missiles.push({
                    element: missile,
                    x: startPos.x,
                    y: startPos.y,
                    target: target,
                    isEnemyMissile: false,
                    isPlayer2: true,
                    crazyTimer: 0,
                    chaosX: 0,
                    chaosY: 0,
                    lastChaosTime: Date.now()
                });
            }
            
            fireFlame2() {
                const currentTime = Date.now();
                if (currentTime - this.tank2LastFlamethrowerSound > this.specialWeaponSoundCooldown) {
                    this.playFlamethrowerSound();
                    this.tank2LastFlamethrowerSound = currentTime;
                }
                const startPos = this.getBulletStartPosition2(); // Use proper positioning like P1
                this.createFlame2(startPos.x, startPos.y, this.tank2Direction);
            }
            
            fireFreezeBlast2() {
                const currentTime = Date.now();
                if (currentTime - this.tank2LastFreezethrowerSound > this.specialWeaponSoundCooldown) {
                    this.playFreezeThrowerSound();
                    this.tank2LastFreezethrowerSound = currentTime;
                }
                const startPos = this.getBulletStartPosition2(); // Use proper positioning like P1
                this.createFreezeBlast2(startPos.x, startPos.y, this.tank2Direction);
            }

            createMissile2(x, y, direction) {
                const missile = document.createElement('div');
                missile.className = 'missile';
                missile.style.position = 'absolute';
                missile.style.width = '12px';
                missile.style.height = '12px';
                missile.style.backgroundColor = '#ff6600'; // Orange missiles for Player 2
                missile.style.borderRadius = '50%';
                missile.style.left = x + 'px';
                missile.style.top = y + 'px';
                missile.style.zIndex = '5';
                
                this.gameContainer.appendChild(missile);
                
                this.missiles.push({
                    element: missile,
                    x: x,
                    y: y,
                    direction: direction,
                    isPlayer2: true
                });
            }

            createFlame2(x, y, direction) {
                // Create multiple flame particles for realistic spread (same as P1) - HEAVILY BALANCED
                const flameCount = 2; // Further reduced from 3 to 2 for better balance (matches P1)
                const spreadAngle = 15; // Further reduced from 25 to 15 degrees for much tighter spread (matches P1)
                
                for (let i = 0; i < flameCount; i++) {
                    setTimeout(() => {
                        const flame = document.createElement('div');
                        flame.className = 'flame';
                        
                        // Create animated flame using frame sequence flam1.png to flam8.png (same as P1)
                        const flameImg = document.createElement('img');
                        flameImg.src = 'assists/powers/flam1.png'; // Start with frame 1
                        flameImg.style.width = '100%';
                        flameImg.style.height = '100%';
                        flameImg.style.objectFit = 'contain';
                        flameImg.style.imageRendering = 'pixelated';
                        flameImg.alt = 'Flame';
                        
                        flame.appendChild(flameImg);
                        
                        // Random size variation for more realistic flames
                        const size = 25 + Math.random() * 15; // 25-40px
                        flame.style.width = size + 'px';
                        flame.style.height = size + 'px';
                        
                        // Calculate spread position
                        const angle = (i - (flameCount - 1) / 2) * (spreadAngle / (flameCount - 1));
                        const radians = (angle * Math.PI) / 180;
                        
                        let offsetX = 0, offsetY = 0;
                        const spread = 8; // Further reduced spread for balance (matches P1)
                        switch(direction) {
                            case 'up':
                                offsetX = Math.sin(radians) * spread;
                                offsetY = -Math.cos(radians) * spread;
                                break;
                            case 'down':
                                offsetX = Math.sin(radians) * spread;
                                offsetY = Math.cos(radians) * spread;
                                break;
                            case 'left':
                                offsetX = -Math.cos(radians) * spread;
                                offsetY = Math.sin(radians) * spread;
                                break;
                            case 'right':
                                offsetX = Math.cos(radians) * spread;
                                offsetY = Math.sin(radians) * spread;
                                break;
                        }
                        
                        flame.style.position = 'absolute';
                        flame.style.left = (x + offsetX) + 'px';
                        flame.style.top = (y + offsetY) + 'px';
                        flame.style.zIndex = '6';
                        
                        this.gameContainer.appendChild(flame);
                        
                        this.flames.push({
                            element: flame,
                            img: flameImg,
                            x: x + offsetX,
                            y: y + offsetY,
                            direction: direction,
                            maxRange: 80 + Math.random() * 20, // Further reduced range 80-100px for balance (matches P1)
                            traveled: 0, // Track distance traveled for range limiting (same as P1)
                            currentFrame: 1,
                            lastFrameTime: Date.now(),
                            isPlayer2: true
                        });
                    }, i * 120); // Much slower stagger for balance (matches P1's 120ms)
                }
            }

            createFreezeBlast2(x, y, direction) {
                const startPos = { x: x, y: y }; // Use provided coordinates (same as P1 using getBulletStartPosition)
                
                // Create multiple freeze particles for realistic spread (same as P1)
                const freezeCount = 3; // Fewer than flame for different feel
                const spreadAngle = 25; // Slightly tighter spread than flame
                
                for (let i = 0; i < freezeCount; i++) {
                    setTimeout(() => {
                        const freeze = document.createElement('div');
                        freeze.className = 'freeze-blast';
                        
                        // Create animated freeze using frame sequence freeze1.png to freeze8.png (same as P1)
                        const freezeImg = document.createElement('img');
                        freezeImg.src = 'assists/powers/freeze1.png'; // Start with frame 1
                        freezeImg.style.width = '100%';
                        freezeImg.style.height = '100%';
                        freezeImg.style.objectFit = 'contain';
                        freezeImg.style.imageRendering = 'pixelated';
                        freezeImg.alt = 'Freeze Blast';
                        
                        freeze.appendChild(freezeImg);
                        
                        // Random size variation for more realistic freeze blasts (same as P1)
                        const size = 30 + Math.random() * 10; // 30-40px (slightly bigger than flame)
                        freeze.style.width = size + 'px';
                        freeze.style.height = size + 'px';
                        
                        // Calculate spread position (same as P1)
                        const angle = (i - (freezeCount - 1) / 2) * (spreadAngle / (freezeCount - 1));
                        const radians = (angle * Math.PI) / 180;
                        
                        let offsetX = 0, offsetY = 0;
                        const spread = 12; // Slightly tighter spread than flame (same as P1)
                        
                        // Apply spread based on tank direction (exactly same as P1)
                        switch(direction) {
                            case 'up':
                                offsetX = Math.sin(radians) * spread;
                                offsetY = -Math.cos(radians) * spread;
                                break;
                            case 'down':
                                offsetX = -Math.sin(radians) * spread;
                                offsetY = Math.cos(radians) * spread;
                                break;
                            case 'left':
                                offsetX = -Math.cos(radians) * spread;
                                offsetY = Math.sin(radians) * spread;
                                break;
                            case 'right':
                                offsetX = Math.cos(radians) * spread;
                                offsetY = -Math.sin(radians) * spread;
                                break;
                        }
                        
                        freeze.style.position = 'absolute';
                        freeze.style.left = (startPos.x + offsetX) + 'px';
                        freeze.style.top = (startPos.y + offsetY) + 'px';
                        freeze.style.zIndex = '6';
                        
                        this.gameContainer.appendChild(freeze);
                        
                        this.freezeBlasts.push({
                            element: freeze,
                            img: freezeImg,
                            x: startPos.x + offsetX,
                            y: startPos.y + offsetY,
                            direction: direction,
                            maxRange: 140 + Math.random() * 50, // Longer range than flame (140-190px vs 120-160px) - same as P1
                            traveled: 0, // Track distance traveled (same as P1)
                            currentFrame: 1, // Track animation frame (same as P1)
                            lastFrameTime: Date.now(),
                            isPlayer2: true
                        });
                        
                        if (i === 0) {
                            console.log('P2 Multi-frame freeze animation started (freeze1-8.png)!');
                        }
                        
                    }, i * 60); // Slightly faster stagger than flame (60ms vs 50ms) - same as P1
                }
            }

            updateWeaponStatus2() {
                if (!this.twoPlayerMode) return;
                let weaponText = '';
                switch(this.tank2WeaponLevel) {
                    case 1:
                        weaponText = 'P2 Weapon: Single Shot';
                        break;
                    case 2:
                        weaponText = 'P2 Weapon: Double Shot';
                        break;
                    case 3:
                        weaponText = 'P2 Weapon: Triple Shot';
                        break;
                }
                this.weaponStatus2.textContent = weaponText;
            }

            updatePowerupStatus2() {
                if (!this.twoPlayerMode) return;
                if (this.tank2CurrentPowerup) {
                    const powerupName = this.tank2CurrentPowerup.type.split('/').pop().split('.')[0];
                    this.powerupStatus2.textContent = `P2 Power: ${powerupName.toUpperCase()}`;
                } else {
                    this.powerupStatus2.textContent = 'P2 Power: None';
                }
            }

            // Xbox Controller Support (Multiple Controllers)
            setupGamepadSupport() {
                window.addEventListener('gamepadconnected', (e) => {
                    console.log('Xbox Controller connected:', e.gamepad.id, 'Index:', e.gamepad.index);
                    
                    // Assign controllers to players
                    if (!this.gamepads.player1.connected) {
                        this.gamepads.player1.connected = true;
                        this.gamepads.player1.index = e.gamepad.index;
                        console.log('Controller assigned to Player 1 (Red Tank)');
                    } else if (!this.gamepads.player2.connected) {
                        this.gamepads.player2.connected = true;
                        this.gamepads.player2.index = e.gamepad.index;
                        console.log('Controller assigned to Player 2 (Green Tank)');
                    }
                    
                    // Legacy support
                    this.gamepadConnected = true;
                    if (this.gamepadIndex === -1) {
                        this.gamepadIndex = e.gamepad.index;
                    }
                });

                window.addEventListener('gamepaddisconnected', (e) => {
                    console.log('Xbox Controller disconnected:', e.gamepad.index);
                    
                    // Remove controller assignments
                    if (this.gamepads.player1.index === e.gamepad.index) {
                        this.gamepads.player1.connected = false;
                        this.gamepads.player1.index = -1;
                        console.log('Player 1 controller disconnected');
                    }
                    if (this.gamepads.player2.index === e.gamepad.index) {
                        this.gamepads.player2.connected = false;
                        this.gamepads.player2.index = -1;
                        console.log('Player 2 controller disconnected');
                    }
                    
                    // Legacy support
                    if (this.gamepadIndex === e.gamepad.index) {
                        this.gamepadConnected = false;
                        this.gamepadIndex = -1;
                    }
                });
            }

            updateGamepadInput() {
                const gamepads = navigator.getGamepads();
                const deadzone = 0.3;
                
                // Player 1 Controller Input (Red Tank)
                if (this.gamepads.player1.connected) {
                    const gamepad1 = gamepads[this.gamepads.player1.index];
                    if (gamepad1) {
                        // Left stick for Player 1 movement
                        const leftStickX = gamepad1.axes[0];
                        const leftStickY = gamepad1.axes[1];
                        
                        // Reset Player 1 movement
                        this.currentDirection = null;
                        
                        if (Math.abs(leftStickX) > deadzone || Math.abs(leftStickY) > deadzone) {
                            if (Math.abs(leftStickX) > Math.abs(leftStickY)) {
                                this.currentDirection = leftStickX > 0 ? 'right' : 'left';
                            } else {
                                this.currentDirection = leftStickY > 0 ? 'down' : 'up';
                            }
                            this.tankDirection = this.currentDirection;
                            this.updateTankRotation();
                        }
                        
                        // A button for Player 1 shooting
                        if (gamepad1.buttons[0].pressed) {
                            this.shoot();
                        }
                    }
                }
                
                // Player 2 Controller Input (Green Tank) - only in two-player mode
                if (this.twoPlayerMode && this.gamepads.player2.connected) {
                    const gamepad2 = gamepads[this.gamepads.player2.index];
                    if (gamepad2) {
                        // Left stick for Player 2 movement
                        const leftStickX = gamepad2.axes[0];
                        const leftStickY = gamepad2.axes[1];
                        
                        // Reset Player 2 movement
                        this.tank2CurrentDirection = null;
                        
                        if (Math.abs(leftStickX) > deadzone || Math.abs(leftStickY) > deadzone) {
                            if (Math.abs(leftStickX) > Math.abs(leftStickY)) {
                                this.tank2CurrentDirection = leftStickX > 0 ? 'right' : 'left';
                            } else {
                                this.tank2CurrentDirection = leftStickY > 0 ? 'down' : 'up';
                            }
                            this.tank2Direction = this.tank2CurrentDirection;
                            this.updateTank2Rotation();
                        }
                        
                        // A button for Player 2 shooting
                        if (gamepad2.buttons[0].pressed) {
                            this.shoot2();
                        }
                    }
                }
                
                // Legacy support for single controller (fallback to Player 2 if two-player mode)
                if (!this.gamepads.player1.connected && !this.gamepads.player2.connected && this.gamepadConnected) {
                    const gamepad = gamepads[this.gamepadIndex];
                    if (gamepad && this.twoPlayerMode) {
                        // Use legacy controller for Player 2
                        const leftStickX = gamepad.axes[0];
                        const leftStickY = gamepad.axes[1];
                        
                        this.tank2CurrentDirection = null;
                        
                        if (Math.abs(leftStickX) > deadzone || Math.abs(leftStickY) > deadzone) {
                            if (Math.abs(leftStickX) > Math.abs(leftStickY)) {
                                this.tank2CurrentDirection = leftStickX > 0 ? 'right' : 'left';
                            } else {
                                this.tank2CurrentDirection = leftStickY > 0 ? 'down' : 'up';
                            }
                            this.tank2Direction = this.tank2CurrentDirection;
                            this.updateTank2Rotation();
                        }
                        
                        if (gamepad.buttons[0].pressed) {
                            this.shoot2();
                        }
                    }
                }
            }

            // COLLISION SYSTEM (Simplified - collisions commented out)
            checkRectCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            checkCollision(bullet, tankPos, tankSize) {
                const tolerance = 8;
                return (bullet.x >= tankPos.x - tolerance && 
                        bullet.x <= tankPos.x + tankSize + tolerance &&
                        bullet.y >= tankPos.y - tolerance && 
                        bullet.y <= tankPos.y + tankSize + tolerance);
            }

            // PROJECTILE UPDATES (Enhanced)
            updateBullets() {
                this.bullets = this.bullets.filter(bullet => {
                    switch(bullet.direction) {
                        case 'up':
                            bullet.y -= this.bulletSpeed;
                            break;
                        case 'down':
                            bullet.y += this.bulletSpeed;
                            break;
                        case 'left':
                            bullet.x -= this.bulletSpeed;
                            break;
                        case 'right':
                            bullet.x += this.bulletSpeed;
                            break;
                    }

                    bullet.element.style.left = bullet.x + 'px';
                    bullet.element.style.top = bullet.y + 'px';

                    // Check enemy collisions
                    for (let enemy of this.enemies) {
                        if (this.checkCollision(bullet, { x: enemy.x, y: enemy.y }, this.tankSize)) {
                            bullet.element.remove();
                            // Reset single-shot system based on bullet type
                            if (bullet.isPlayerBullet) {
                                this.hasActiveShot = false;
                            } else if (bullet.isPlayer2) {
                                this.tank2HasActiveShot = false;
                            }
                            // Pass correct player info to handleEnemyHit
                            const player = bullet.isPlayer2 ? 'player2' : 'player1';
                            this.handleEnemyHit(enemy, player);
                            return false;
                        }
                    }

                    // Check boss collision
                    if (this.boss && this.checkCollision(bullet, { x: this.boss.x, y: this.boss.y }, this.bossSize)) {
                        bullet.element.remove();
                        // Reset single-shot system based on bullet type
                        if (bullet.isPlayerBullet) {
                            this.hasActiveShot = false;
                        } else if (bullet.isPlayer2) {
                            this.tank2HasActiveShot = false;
                        }
                        this.handleBossHit();
                        return false;
                    }

                    // Check boundaries
                    if (bullet.x < -20 || bullet.x > this.containerWidth + 20 || 
                        bullet.y < -20 || bullet.y > this.containerHeight + 20) {
                        bullet.element.remove();
                        // Reset single-shot system based on bullet type
                        if (bullet.isPlayerBullet) {
                            this.hasActiveShot = false;
                        } else if (bullet.isPlayer2) {
                            this.tank2HasActiveShot = false;
                        }
                        return false;
                    }

                    return true;
                });
            }

            updateMissiles() {
                this.missiles = this.missiles.filter(missile => {
                    const currentTime = Date.now();
                    
                    if (missile.isEnemyMissile) {
                        // Enemy missile moves toward stored target position
                        const dx = missile.target.x - missile.x;
                        const dy = missile.target.y - missile.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 0) {
                            missile.x += (dx / distance) * this.missileSpeed;
                            missile.y += (dy / distance) * this.missileSpeed;
                        }

                        // Check player collision
                        if (this.checkCollision(missile, this.tankPosition, this.tankSize)) {
                            missile.element.remove();
                            this.handlePlayerHit();
                            return false;
                        }

                        // Check Player 2 collision (if two-player mode is active)
                        if (this.twoPlayerMode && this.checkCollision(missile, this.tank2Position, this.tankSize)) {
                            missile.element.remove();
                            this.handlePlayer2Hit();
                            return false;
                        }
                    } else {
                        // PLAYER MISSILE - CRAZY MOVEMENT WITH HOMING
                        
                        // Generate new chaos movement every 80ms for unpredictable path
                        if (currentTime - missile.lastChaosTime > 80) {
                            missile.chaosX = (Math.random() - 0.5) * 6; // Random -3 to +3
                            missile.chaosY = (Math.random() - 0.5) * 6; // Random -3 to +3
                            missile.lastChaosTime = currentTime;
                        }
                        
                        if (missile.target && (this.enemies.includes(missile.target) || missile.target === this.boss)) {
                            // HOMING BEHAVIOR with CHAOS
                            const dx = missile.target.x - missile.x;
                            const dy = missile.target.y - missile.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance > 0) {
                                // Base homing movement
                                const homingX = (dx / distance) * this.missileSpeed * 0.7; // 70% homing
                                const homingY = (dy / distance) * this.missileSpeed * 0.7; // 70% homing
                                
                                // Add crazy chaos movement
                                missile.x += homingX + missile.chaosX;
                                missile.y += homingY + missile.chaosY;
                            }
                        } else {
                            // No target - move forward with crazy chaos
                            let forwardX = 0, forwardY = 0;
                            const playerDirection = missile.isPlayer2 ? this.tank2Direction : this.tankDirection;
                            switch(playerDirection) {
                                case 'up':
                                    forwardY = -this.missileSpeed * 0.5;
                                    break;
                                case 'down':
                                    forwardY = this.missileSpeed * 0.5;
                                    break;
                                case 'left':
                                    forwardX = -this.missileSpeed * 0.5;
                                    break;
                                case 'right':
                                    forwardX = this.missileSpeed * 0.5;
                                    break;
                            }
                            
                            missile.x += forwardX + missile.chaosX;
                            missile.y += forwardY + missile.chaosY;
                        }

                        // Check enemy collisions
                        for (let enemy of this.enemies) {
                            if (this.checkCollision(missile, { x: enemy.x, y: enemy.y }, this.tankSize)) {
                                missile.element.remove();
                                const player = missile.isPlayer2 ? 'player2' : 'player1';
                                this.handleEnemyHit(enemy, player);
                                return false;
                            }
                        }

                        // Check boss collision
                        if (this.boss && this.checkCollision(missile, { x: this.boss.x, y: this.boss.y }, this.bossSize)) {
                            missile.element.remove();
                            this.handleBossHit();
                            return false;
                        }
                    }

                    // Update missile rotation based on movement direction for visual effect
                    const rotationAngle = Math.atan2(missile.chaosY || 0, missile.chaosX || 1) * (180 / Math.PI);
                    missile.element.style.transform = `rotate(${rotationAngle}deg)`;

                    missile.element.style.left = missile.x + 'px';
                    missile.element.style.top = missile.y + 'px';

                    // Check boundaries
                    if (missile.x < -50 || missile.x > this.containerWidth + 50 || 
                        missile.y < -50 || missile.y > this.containerHeight + 50) {
                        missile.element.remove();
                        return false;
                    }

                    return true;
                });
            }

            updateFlames() {
                this.flames = this.flames.filter(flame => {
                    const currentTime = Date.now();
                    
                    // Animate flame frames (flam1.png to flam8.png)
                    if (currentTime - flame.lastFrameTime > 80) { // Change frame every 80ms for smooth animation
                        flame.currentFrame++;
                        if (flame.currentFrame > 8) {
                            flame.currentFrame = 1; // Loop back to frame 1
                        }
                        flame.img.src = `assists/powers/flam${flame.currentFrame}.png`;
                        flame.lastFrameTime = currentTime;
                    }
                    
                    // Update position based on direction
                    switch(flame.direction) {
                        case 'up':
                            flame.y -= this.flameSpeed;
                            break;
                        case 'down':
                            flame.y += this.flameSpeed;
                            break;
                        case 'left':
                            flame.x -= this.flameSpeed;
                            break;
                        case 'right':
                            flame.x += this.flameSpeed;
                            break;
                    }
                    
                    // Track distance traveled
                    flame.traveled += this.flameSpeed;
                    
                    // Apply fade effect as flame reaches max range
                    const fadeStart = flame.maxRange * 0.7; // Start fading at 70% of max range
                    if (flame.traveled > fadeStart) {
                        const fadeProgress = (flame.traveled - fadeStart) / (flame.maxRange - fadeStart);
                        const opacity = 1 - fadeProgress;
                        flame.element.style.opacity = Math.max(0, opacity);
                        
                        // Reduce size as it fades
                        const scale = 1 - (fadeProgress * 0.3);
                        flame.element.style.transform = `scale(${scale})`;
                    }

                    flame.element.style.left = flame.x + 'px';
                    flame.element.style.top = flame.y + 'px';

                    // Check if flame has reached maximum range
                    if (flame.traveled >= flame.maxRange) {
                        flame.element.remove();
                        return false;
                    }

                    // Check enemy collisions - flames have wider hit area
                    for (let enemy of this.enemies) {
                        const hitDistance = 35; // Wider hit area for flames
                        if (this.checkCollision(flame, { x: enemy.x, y: enemy.y }, hitDistance)) {
                            // Don't remove flame on hit - flames pass through
                            
                            // Reduced flame damage - only 30% chance to deal damage per hit
                            if (Math.random() < 0.30) {
                                const player = flame.isPlayer2 ? 'player2' : 'player1';
                                this.handleEnemyHit(enemy, player);
                                console.log('Flame dealt damage!');
                            }
                            
                            // Create burning effect on enemy
                            if (!this.burningTanks.has(enemy.id)) {
                                this.createBurningEffect(enemy, enemy.id);
                            }
                            
                            // Reduce flame power after hitting
                            flame.maxRange -= 20;
                        }
                    }

                    // Check boss collision - wider area
                    if (this.boss) {
                        const bossHitDistance = 60; // Larger hit area for boss
                        if (this.checkCollision(flame, { x: this.boss.x, y: this.boss.y }, bossHitDistance)) {
                            // Reduced flame damage - only 20% chance to deal damage to boss per hit
                            if (Math.random() < 0.20) {
                                this.handleBossHit();
                                console.log('Flame dealt damage to boss!');
                            }
                            
                            // Create burning effect on boss
                            if (!this.burningTanks.has('boss')) {
                                this.createBurningEffect(this.boss, 'boss');
                            }
                            
                            // Reduce flame power after hitting boss
                            flame.maxRange -= 15;
                        }
                    }

                    // Check boundaries (flames disappear at edges)
                    if (flame.x < -30 || flame.x > this.containerWidth + 30 || 
                        flame.y < -30 || flame.y > this.containerHeight + 30) {
                        flame.element.remove();
                        return false;
                    }

                    return true;
                });
            }

            updateFreezeBlasts() {
                this.freezeBlasts = this.freezeBlasts.filter(freeze => {
                    const currentTime = Date.now();
                    
                    // Animate freeze frames (freeze1.png to freeze8.png)
                    if (currentTime - freeze.lastFrameTime > 90) { // Slightly slower than flame (90ms vs 80ms)
                        freeze.currentFrame++;
                        if (freeze.currentFrame > 8) {
                            freeze.currentFrame = 1; // Loop back to frame 1
                        }
                        freeze.img.src = `assists/powers/freeze${freeze.currentFrame}.png`;
                        freeze.lastFrameTime = currentTime;
                    }
                    
                    // Update position based on direction
                    switch(freeze.direction) {
                        case 'up':
                            freeze.y -= this.freezeSpeed;
                            break;
                        case 'down':
                            freeze.y += this.freezeSpeed;
                            break;
                        case 'left':
                            freeze.x -= this.freezeSpeed;
                            break;
                        case 'right':
                            freeze.x += this.freezeSpeed;
                            break;
                    }
                    
                    // Track distance traveled
                    freeze.traveled += this.freezeSpeed;
                    
                    // Apply fade effect as freeze reaches max range
                    const fadeStart = freeze.maxRange * 0.8; // Start fading later than flame (80% vs 70%)
                    if (freeze.traveled > fadeStart) {
                        const fadeProgress = (freeze.traveled - fadeStart) / (freeze.maxRange - fadeStart);
                        const opacity = 1 - fadeProgress;
                        freeze.element.style.opacity = Math.max(0, opacity);
                        
                        // Reduce size as it fades
                        const scale = 1 - (fadeProgress * 0.2); // Less scaling than flame
                        freeze.element.style.transform = `scale(${scale})`;
                    }

                    freeze.element.style.left = freeze.x + 'px';
                    freeze.element.style.top = freeze.y + 'px';

                    // Check if freeze has reached maximum range
                    if (freeze.traveled >= freeze.maxRange) {
                        freeze.element.remove();
                        return false;
                    }

                    // Check enemy collisions - freeze effect with wider area + minor damage
                    for (let enemy of this.enemies) {
                        const hitDistance = 45; // Even wider hit area than before
                        if (this.checkCollision(freeze, { x: enemy.x, y: enemy.y }, hitDistance)) {
                            // Remove freeze on hit (unlike flame which passes through)
                            freeze.element.remove();
                            
                            // Apply freeze effect
                            this.activateEnemyFreeze(enemy);
                            
                            // Create freeze visual effect
                            if (!this.frozenEffects.has(enemy.id)) {
                                this.createFreezeEffect(enemy, enemy.id);
                            }
                            
                            // Deal minor damage (15% chance to deal extra damage - reduced from 25%)
                            if (Math.random() < 0.15) {
                                const player = freeze.isPlayer2 ? 'player2' : 'player1';
                                this.handleEnemyHit(enemy, player);
                                console.log('Freeze blast dealt bonus damage!');
                            }
                            
                            // Award minor points for freeze hit
                            this.score += 10;
                            this.scoreElement.textContent = `Score: ${this.score}`;
                            
                            return false;
                        }
                    }

                    // Check boss collision - freeze effect with minor damage
                    if (this.boss) {
                        const bossHitDistance = 80; // Even larger hit area for boss
                        if (this.checkCollision(freeze, { x: this.boss.x, y: this.boss.y }, bossHitDistance)) {
                            freeze.element.remove();
                            
                            // Boss can't be frozen but takes minor damage
                            if (Math.random() < 0.20) { // 20% chance for minor damage - reduced from 30%
                                this.handleBossHit();
                                console.log('Freeze blast dealt minor damage to boss!');
                            } else {
                                // Just slow down boss briefly (visual effect only)
                                this.boss.element.style.filter = 'brightness(0.7) hue-rotate(180deg)';
                                setTimeout(() => {
                                    if (this.boss) {
                                        this.boss.element.style.filter = 'none';
                                    }
                                }, 500);
                                console.log('Boss briefly slowed by freeze blast!');
                            }
                            
                            // Award minor points for boss hit
                            this.score += 15;
                            this.scoreElement.textContent = `Score: ${this.score}`;
                            
                            return false;
                        }
                    }

                    // Check boundaries
                    if (freeze.x < -30 || freeze.x > this.containerWidth + 30 || 
                        freeze.y < -30 || freeze.y > this.containerHeight + 30) {
                        freeze.element.remove();
                        return false;
                    }

                    return true;
                });
            }

            activateEnemyFreeze(enemy) {
                console.log('Enemy frozen!');
                
                this.frozenEnemies.add(enemy.id);
                enemy.element.classList.add('frozen');
                
                // Unfreeze after 5 seconds
                setTimeout(() => {
                    if (this.enemies.includes(enemy)) {
                        this.frozenEnemies.delete(enemy.id);
                        enemy.element.classList.remove('frozen');
                        console.log('Enemy unfrozen');
                    }
                }, 5000);
            }

            updateEnemyBullets() {
                this.enemyBullets = this.enemyBullets.filter(bullet => {
                    if (bullet.dx !== undefined && bullet.dy !== undefined) {
                        // Boss bullets with custom direction
                        bullet.x += bullet.dx;
                        bullet.y += bullet.dy;
                    } else {
                        // Regular enemy bullets
                        switch(bullet.direction) {
                            case 'up':
                                bullet.y -= this.enemyBulletSpeed;
                                break;
                            case 'down':
                                bullet.y += this.enemyBulletSpeed;
                                break;
                            case 'left':
                                bullet.x -= this.enemyBulletSpeed;
                                break;
                            case 'right':
                                bullet.x += this.enemyBulletSpeed;
                                break;
                        }
                    }

                    bullet.element.style.left = bullet.x + 'px';
                    bullet.element.style.top = bullet.y + 'px';

                    // Check collision with Player 1
                    if (this.checkCollision(bullet, this.tankPosition, this.tankSize)) {
                        bullet.element.remove();
                        this.handlePlayerHit();
                        if (bullet.enemyId) {
                            this.resetEnemyShot(bullet.enemyId);
                        }
                        return false;
                    }

                    // Check collision with Player 2 (if two-player mode is active)
                    if (this.twoPlayerMode && this.checkCollision(bullet, this.tank2Position, this.tankSize)) {
                        bullet.element.remove();
                        this.handlePlayer2Hit();
                        if (bullet.enemyId) {
                            this.resetEnemyShot(bullet.enemyId);
                        }
                        return false;
                    }

                    // Check boundaries
                    if (bullet.x < -20 || bullet.x > this.containerWidth + 20 || 
                        bullet.y < -20 || bullet.y > this.containerHeight + 20) {
                        bullet.element.remove();
                        if (bullet.enemyId) {
                            this.resetEnemyShot(bullet.enemyId);
                        }
                        return false;
                    }

                    return true;
                });
            }

            resetEnemyShot(enemyId) {
                const enemy = this.enemies.find(e => e.id === enemyId);
                if (enemy) {
                    enemy.hasActiveShot = false;
                }
            }

            // STAGE MANAGEMENT
            loadStage() {
                const backgroundImage = this.stageBackgrounds[this.currentStage - 1];
                console.log(`Loading Stage ${this.currentStage}: ${backgroundImage}`);
                
                // Set background image
                this.gameCanvas.style.backgroundImage = `url('${backgroundImage}')`;
                this.gameCanvas.style.backgroundSize = 'cover';
                this.gameCanvas.style.backgroundPosition = 'center';
                this.gameCanvas.style.backgroundRepeat = 'no-repeat';
                
                this.stageInfoElement.textContent = `Stage: ${this.currentStage}`;
                
                console.log(`Loaded Stage ${this.currentStage}: ${backgroundImage}`);
                
                // Reset tank position
                this.tankPosition = { x: 100, y: 200 };
                this.updateTankPosition();
                
                // Clear existing enemies and projectiles
                this.enemies.forEach(enemy => enemy.element.remove());
                this.enemies = [];
                this.bullets.forEach(bullet => bullet.element.remove());
                this.bullets = [];
                this.enemyBullets.forEach(bullet => bullet.element.remove());
                this.enemyBullets = [];
                
                // Generate obstacles (sprites ready, no collision logic)
                // this.generateObstacles(); // DISABLED - User wants to assign them manually later
                this.spawnEnemies();
            }

            generateObstacles() {
                // Clear existing obstacles
                this.obstacles.forEach(obstacle => obstacle.element.remove());
                this.obstacles = [];

                // Generate random obstacles for visual variety
                const numObstacles = 3 + Math.floor(Math.random() * (this.currentStage * 2));
                
                for (let i = 0; i < numObstacles; i++) {
                    const obstacleType = this.obstacleTypes[Math.floor(Math.random() * this.obstacleTypes.length)];
                    const x = Math.random() * (this.containerWidth - this.obstacleSize);
                    const y = Math.random() * (this.containerHeight - this.obstacleSize);
                    
                    // Don't place obstacles too close to player spawn
                    const distanceFromPlayer = Math.sqrt(
                        Math.pow(x - 100, 2) + Math.pow(y - 200, 2)
                    );
                    
                    if (distanceFromPlayer > 100) {
                        this.createObstacle(x, y, obstacleType);
                    }
                }
            }

            createObstacle(x, y, type) {
                const obstacle = document.createElement('div');
                obstacle.className = 'obstacle';
                obstacle.innerHTML = `<img src="${type}" alt="Obstacle">`;
                obstacle.style.left = x + 'px';
                obstacle.style.top = y + 'px';
                
                this.gameContainer.appendChild(obstacle);
                
                this.obstacles.push({
                    element: obstacle,
                    x: x,
                    y: y,
                    width: this.obstacleSize,
                    height: this.obstacleSize,
                    type: type
                });
            }

            nextStage() {
                this.currentStage++;
                if (this.currentStage > this.maxStages) {
                    this.currentStage = 1;
                }
                this.loadStage();
                console.log(`Advanced to Stage ${this.currentStage}`);
            }

            // VISUAL EFFECTS UPDATE METHODS
            updateBurningEffects() {
                const currentTime = Date.now();
                
                this.burningTanks.forEach((burningData, tankId) => {
                    // Check if burning duration has expired
                    if (currentTime - burningData.startTime > this.burningDuration) {
                        // Remove burning effect
                        burningData.effectElement.remove();
                        this.burningTanks.delete(tankId);
                        console.log(`Tank ${tankId} is no longer burning`);
                        return;
                    }
                    
                    // Update effect position to follow tank
                    if (burningData.tank) {
                        burningData.effectElement.style.left = (burningData.tank.x - 5) + 'px';
                        burningData.effectElement.style.top = (burningData.tank.y - 5) + 'px';
                    }
                    
                    // Animate burning frames (burning1.png to burning4.png)
                    if (currentTime - burningData.lastFrameTime > 150) { // Change every 150ms
                        burningData.currentFrame = (burningData.currentFrame % 4) + 1;
                        burningData.burningImg.src = `assists/sfx/burning${burningData.currentFrame}.png`;
                        burningData.lastFrameTime = currentTime;
                    }
                    
                    // Apply burning damage every 500ms
                    if (currentTime - burningData.damageTimer > this.burningDamageInterval) {
                        this.applyBurningDamage(tankId, burningData.tank);
                        burningData.damageTimer = currentTime;
                    }
                });
            }

            updateFreezeEffects() {
                const currentTime = Date.now();
                
                this.frozenEffects.forEach((freezeData, tankId) => {
                    // Check if tank is still frozen
                    if (!this.frozenEnemies.has(tankId) && tankId !== 'player') {
                        // Remove freeze effect when tank unfreezes
                        freezeData.effectElement.remove();
                        this.frozenEffects.delete(tankId);
                        console.log(`Tank ${tankId} freeze effect removed`);
                        return;
                    }
                    
                    // Update effect position to follow tank
                    if (freezeData.tank) {
                        freezeData.effectElement.style.left = (freezeData.tank.x - 5) + 'px';
                        freezeData.effectElement.style.top = (freezeData.tank.y - 5) + 'px';
                    }
                    
                    // Animate freeze frames (getfreeze1.png to getfreeze3.png)
                    if (currentTime - freezeData.lastFrameTime > 200) { // Change every 200ms
                        freezeData.currentFrame = (freezeData.currentFrame % 3) + 1;
                        freezeData.freezeImg.src = `assists/sfx/getfreeze${freezeData.currentFrame}.png`;
                        freezeData.lastFrameTime = currentTime;
                    }
                });
            }

            applyBurningDamage(tankId, tank) {
                if (tankId === 'player') {
                    // Player takes burning damage
                    console.log('Player takes burning damage!');
                    // You could reduce player health here if you have a health system
                } else {
                    // Enemy takes burning damage
                    const currentHits = this.enemyHitPoints.get(tankId) || 4;
                    const newHits = Math.max(0, currentHits - 0.5); // Half damage from burning
                    this.enemyHitPoints.set(tankId, newHits);
                    
                    console.log(`Enemy ${tankId} takes burning damage! Health: ${newHits}`);
                    
                    if (newHits <= 0) {
                        // Enemy dies from burning
                        const enemy = this.enemies.find(e => e.id === tankId);
                        if (enemy) {
                            this.handleEnemyHit(enemy);
                        }
                    }
                }
            }

            // MAIN GAME LOOP
            gameLoop() {
                // Only run game loop if game has started
                if (!this.gameStarted) {
                    requestAnimationFrame(() => this.gameLoop());
                    return;
                }
                
                // Update Xbox Controller Input (both players)
                this.updateGamepadInput();
                
                // Check for auto powerup spawning every 25 seconds
                const currentTime = Date.now();
                if (currentTime - this.powerupSpawnTimer >= this.powerupSpawnInterval) {
                    this.spawnRandomPowerup();
                    this.powerupSpawnTimer = currentTime;
                }
                
                // Spawn initial enemy group if none exist and boss hasn't spawned and we haven't reached kill limit
                if (this.enemies.length === 0 && !this.bossSpawned && this.currentEnemyCount < this.maxEnemies && this.enemiesKilled < this.maxEnemiesBeforeBoss) {
                    console.log('Spawning initial enemy group...');
                    this.spawnEnemyGroup();
                }
                
                // Update Player 1 movement
                this.moveTank();
                
                // Update Player 2 movement (if two-player mode is active)
                if (this.twoPlayerMode) {
                    this.moveTank2();
                }
                
                // Update AI
                this.updateEnemies();
                this.updateBoss();
                
                // Update projectiles
                this.updateBullets();
                this.updateMissiles();
                this.updateFlames();
                this.updateFreezeBlasts();
                this.updateEnemyBullets();
                
                // Update visual effects
                this.updateBurningEffects();
                this.updateFreezeEffects();
                
                // Continue loop
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            new TankGame();
        });

        // Prevent scrolling on mobile
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
                